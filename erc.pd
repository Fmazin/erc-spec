## Executable Research Compendium


This is the technical specification of the Executable Research Compendium (ERC).


**Read the specification** and **get support**.


### Guides


Are you a **scientist** and want to publish your research as an ERC? Read **user guides for authors**:


- ERC creation
- ERC examination
- ERC template


Are you a **developer** and want to build applications for ERCs? Read **user guides for developers**:


- Developer guide


Are your a **librarian** or **preservationist** and want to use ERCs for archival of scholarly works? Read **user guides for librarians and preservationists**:


- ERC & OAIS


### Credits


This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research


[![Opening Reproducible Research](/home/daniel/git/o2r/erc-spec/site/./o2r-logo.png)](http://o2r.info)


### License


![CC-0 Button](https://licensebuttons.net/p/zero/1.0/88x31.png)


The o2r Executable Research Compendium specification is licensed under [Creative Commons CC0 1.0 Universal License](https://creativecommons.org/publicdomain/zero/1.0/), see file `LICENSE`.
To the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work.
This work is published from: Germany.


<div class="buildinfo">Build @@VERSION@@ @ @@TIMESTAMP@@</div>


## ERC specification


An Executable Research Compendium (ERC) is a packaging convention for computational research.
It provides a well-defined structure for data, code, text, documentation, and user interface controls for a piece of research and is suitable for long-term archival. As such it can also be perceived as a digital object or asset.


<div class="admonition note"><p class="admonition-title">Note</p><p>This is a draft specification. If you have comments or suggestions please file them in the . If you have explicit changes please fork the  and submit a pull request.
</p></div>

### Preface


#### Version


Specification version: `1`


<div class="admonition warning"><p class="admonition-title">Warning</p><p>This version is _under development_!
</p></div>

#### Notational conventions


The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in [RFC 2119][rfc2119].


The key words "unspecified", "undefined", and "implementation-defined" are to be interpreted as described in the [rationale for the C99 standard][c99-unspecified].


#### Purpose, target audience, and context


This specification defines a structure to transport and execute a computational scientific analyses (cf. [computational science](https://en.wikipedia.org/wiki/Computational_science)).
It carries technical and conceptual details on how to implement the reproducibility specifications and is as such most suitable **for developers**.
**Authors** may feel more comfortable with the _[user guides](/#user-guides)_.


These analyses typically comprise a workspace on a researcher's computer, that contains _data_, _code_, third party software or libraries, and outputs research results such as plots.
Code and libraries are required in executable form to re-do a specific analysis.
Research is only put into a context by a _textual_ publication, a research paper, which is published in [scholarly communication](https://en.wikipedia.org/wiki/Scholarly_communication).
The text comes in two forms: one that is machine readable, and another one that is suitable for being read by humans.
The latter is often derived, or "rendered" from the former and can be static, visual, or even interactive following a trend towards more interactivity between reader and scientific publication.


Putting all of these elements in a self-contained bundle allows examining, reproducing, transferring, archiving, and formal validation of computational research results.
The ERC specification also defines metadata and file structures to support these actions.


#### Major constituents and design goals


Three major constituents classify user interaction with ERC:


- [**Create**](../glossary.md#create) means transforming a workspace with data, code and text into an ERC.
- [**Examine**](../glossary.md#examine) means looking at depths of an ERC, scrutinizing its contents.
- [**Discover**](../glossary.md#discover) means searching for content powered by ERC properties, such as text, content metadata, code metadata et cetera.


A core design goal is _simplicity_.
This specification should not re-do something which already exists (if it is an open specification or tool).
It must be possible to create a valid and working ERC _manually_, while supporting tools should be able to cover typical use cases with minimal required input by a creating user.


The final important notion is the one of _nested containers_.
We acknowledge well defined standards for packaging a set of files, and different approaches to create an executable code package.
Therefore an ERC comprises _one or more containers but is itself subject to being put into a container_.
We distinguish these containers into the inner or "runtime" container and the outer container, which is used for transfer of complete ERC and not content-aware validation.


#### How to use an ERC


The steps to (re-)run the analysis contained in an ERC as part of an [examination](../glossary.md#examine) are as follows:


- (if compressed first extract then) unpack the ERC's outer container
- execute the runtime container
- compare the output files contained in the outer container with the output files just created by the runtime container


This way an ERC allows computational reproducibility based on the original code and data.


### ERC structure


#### Base directory


An ERC MUST has a _base directory_. All paths within this document are relative to this base directory.


The base directory MUST contain an [ERC configuration file](#erc-configuration-file).


Besides the files mentioned in this specification, the base directory MAY contain any other files and directories.


#### Main & display file


An ERC MUST have a _main file, i.e. the file which contains the text and instructions being the basis for the scientific publication describing the packaged analysis.
An ERC MUST have a _display file_, i.e. the file which is shown to the user first when he opens an ERC in a supporting platform or tool.


_Main file_ and _display file_ MUST NOT be the same file.


The _main file_ MUST be _executable_ in the sense that a software reads it as the input of a process to create the _display file_.
The _main file_'s name SHOULD be `main` with an appropriate file extension and [media type](https://en.wikipedia.org/wiki/Media_type).


<div class="admonition note"><p class="admonition-title">Note</p><p>The _main file_ thus follows the [literate programming paradigm](https://en.wikipedia.org/wiki/Literate_programming).
</p></div>

<div class="admonition tip"><p class="admonition-title">Example</p><p>If the main file is an R Markdown document, then the file extension should be `.Rmd` and the media type `text/markdown`.
A file `main.Rmd` will consequently be automatically identified by an implementation as the ERC's _main file_.
</p></div>

The display file's name SHOULD be `display` with an appropriate file extension and media type.


<div class="admonition tip"><p class="admonition-title">Example</p><p>If the display file is an Hypertext Markup Language (HTML) document, then the file extension should be `.htm` or `.html` and the media type `text/html`.
A file `display.html` will consequently be automatically identified by an implementation as the ERC's _display file_.
</p></div>

The ERC MAY use an interactive document with interactive figures and control elements for the packaged computations as the _display file_.
The _interactive display file_ MUST have `HTML` format and SHOULD be valid [HTML5](https://www.w3.org/TR/html5/).


<div class="admonition tip"><p class="admonition-title">Example</p><p>Typical examples for the two core documents are R Markdown with HTML output (i.e. `main.Rmd` and `display.html`), or an `R` script creating a PNG file (i.e. `main.R` and `display.png`).
</p></div>

#### Nested runtime


The embedding of a representation of the original runtime environment, in which an analysis was conducted, is crucial for supporting reproducible computations.
Every ERC MUST include two such such representations:


1. an **executable runtime image** of the original analysis environment for re-running the packaged analysis, and
2. a **runtime manifest** documenting the image's contents as a complete, self-consistent recipe of the runtime image's contents which is a machine-readable format that allows a respective tool to create the runtime image.


The image MUST be stored as a file, e.g. a "binary", in the ERC base directory.
The name of the archive file MUST be configured in the ERC configuration file in the node `image` under the root-level node `execution`.


The manifest MUST be stored as a text file in the ERC base directory.
The name of the manifest file MUST be configured in the ERC configuration file in the node `manifest` under the root-level node `execution`.


### ERC configuration file


The ERC configuration file is the _reproducibility manifest_ for an ERC. It defines the main entry points for actions performed on an ERC and core metadata elements.


#### Name, format, and encoding


The filename MUST be `erc.yml` and it MUST be located in the base directory.
The contents MUST be valid [YAML 1.2](http://yaml.org/).
The file MUST be encoded in `UTF-8` and MUST NOT contain a byte-order mark (BOM).


#### Basic fields


The first document content of this file MUST contain the following string nodes at the root level.


- `spec_version`: a text string noting the version of the used ERC specification. The appropriate version for an ERC conforming to this version of the specification is `1`.
- `id`: globally unique identifier for a specific ERC. This SHOULD be a URI (see [rfc3986][rfc3986]) or a [UUID][uuid], Version 4.


The main and display file MAY be defined in root-level nodes named `main` and `display` respectively, if they differ from the default file names.
If they are not defined and multiple documents use the name `main.[ext]` or `display.[ext]`, an implementation SHOULD use the first file in [alphabetical order](https://en.wikipedia.org/wiki/Alphabetical_order).


<div class="admonition tip"><p class="admonition-title">Example of ERC configuration file with user-defined main and display files</p><p>```yml
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
main: the_paper_document.rmd
display: paper.html
```
</p></div>

#### Control statements


The configuration file MUST contain statements to control the runtime container.


These statements MUST be in an array under the root-level node `execution` in the ERC configuration file in the order in which they must be executed.


Implementations SHOULD support a list of [bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) commands as control statements.
These commands are given as a list under the node `cmd` under the root-level node `execution`.
If extensions use non-bash commands, they MUST define own nodes under the `execution` node and SHOULD define defaults.


The execution statements MAY ensure the re-computation being independent from the environment, which may be different depending on the host of the execution environment.
For example, the time zone could be fixed via an environment variable `TZ=CET`, so output formatting of timestamps does not break [checking](../glossary.md#check).
This is in addition to ERC authors handling such parameters at a script level.


<div class="admonition tip"><p class="admonition-title">Example for control statements</p><p>```yml
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
execution:
  cmd:
    - `./prepare.sh --input my_data`
    - `./execute.sh --output results --iterations 3`
```
</p></div>

#### License metadata


The file `erc.yml` MUST contain a first level node `licenses` with licensing information for the code, data, and text contained.
Each of these three have distinct requirements, hence different licenses need to be applied.


The node `licenses` MUST have five child nodes: `text`, `data`, `code`, `ui_bindings`, and `metadata`.


<div class="admonition note"><p class="admonition-title">Note</p><p>There is currently no mechanism to define the licenses of the used libraries, as manual creation would be tedious.
Tools for automatic creation of ERC may add such detailed licensing information and define an extension to the ERC
</p></div>

The content of each of these child nodes MUST have one of the following values:


- text string with license identifier or license text. This SHOULD be a standardized identifier of an existing license as defined by the [Open Definition Licenses Service](http://licenses.opendefinition.org/), or
- a dictionary of all files or directories and their respective license, each of the values following the previous statement. The node values are the file paths relative to the base directory.


<div class="admonition tip"><p class="admonition-title">Example for global licenses</p><p>```yml
    ---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
licenses:
  code: Apache-2.0
  data: ODbL-1.0
  text: CC0-1.0
      ui_bindings: CC0-1.0
      metadata: CC0-1.0
```
</p></div>

<div class="admonition tip"><p class="admonition-title">Example using specific licenses for files</p><p>```yml
---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
licenses:
  code:
    others_lib.bin: MIT
    my_code.c: GPL-3.0
  data:
	facts.csv: ODbL-1.0
  text:
    README.md: CC0-1.0
        paper.Rmd: CC-BY-4.0
      ui_bindings: CC0-1.0
      metadata: CC0-1.0
```
</p></div>

<div class="admonition note"><p class="admonition-title">Note</p><p>It IS NOT possible to assign one license to a directory and override that assignment or a single file within that directory, NOR IS it possible to use globs or regular expressions.
</p></div>

#### Comprehensive example of erc.yml


The following example shows all possible fields of the ERC specification with example values.


```yml
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
main: paper.rmd
display: paper.html
execution:
  cmd: "Rscript -e 'rmarkdown::render(input = \"paper.Rmd\", output_format = \"html\")'"
licenses:
  code:
    others_lib.bin: MIT
    my_code.c: GPL-3.0
  data:
	facts.csv: ODbL-1.0
  text:
    README.md: CC0-1.0
    paper.Rmd: CC-BY-4.0
  ui_bindings: CC0-1.0
  metadata: CC0-1.0
structure:
  convention: https://github.com/ropensci/rrrpkg
ui_bindings:
  interactive: true
  bindings:
    - purpose: http://.../data-inspection
      widget: http://.../tabular-browser
      code: [...]
      data: [...]
      text: [...]
    - purpose: http://.../parameter-manipulation
      widget: http://.../dropdown
```


The path to the ERC configuration file subsequently MUST be `<path-to-bag>/data/erc.yml`.


### Docker runtime


The ERC uses [Docker](http://docker.com/) to define, build, and store the nested runtime environment, i.e. the inner container.


#### Runtime image


The _runtime environment or image_ MUST be represented by a Docker image v1.2.0.


<div class="admonition note"><p class="admonition-title">Note</p><p>A concrete implementation of ERC may choose to rely on constructing the runtime environment from the manifest when needed, e.g. for export to a repository, while the ERC is constructed.
</p></div>

The base directory MUST contain a tarball.


The image MUST have a [_label_](https://docs.docker.com/engine/reference/commandline/build/#options) of the name `erc` with the ERC's id as value, e.g. `erc=b9b0099e-9f8d-4a33-8acf-cb0c062efaec`.


The image file MAY be compressed.


The tar archive file names SHOULD be `image.tar`, or `image.tar.gz` if a [gzip compression is used for the archive](https://en.wikipedia.org/wiki/Tar_(computing)#Suffixes_for_compressed_files) with an appropriate file extension, such as `.tar`, `tar.gz` or `.bin`, and have an appropriate mime type, e.g. `application/vnd.oci.image.layer.tar+gzip`.


<div class="admonition note"><p class="admonition-title">Note</p><p>Before exporting the Docker image, first [build it](https://docs.docker.com/engine/reference/commandline/build/) from the Dockerfile, including the label which can be used to extract the image identifier, for example:
</p></div>

    ```bash
    docker build --label erc=b9b0099e-9f8d-4a33-8acf-cb0c062efaec .
    docker images --filter "label=erc=b9b0099e-9f8d-4a33-8acf-cb0c062efaec"
    docker save $(docker images --filter "label=erc=1234" -q) > image.tar
    # save with compression:
    docker save $(docker images --filter "label=erc=1234" -q) | gzip -c >     image.tar.gz
    ```


    Do _not_ use `docker export`, because it is used to create a snapshot of a container, which must not match the Dockerfile anymore as it may have been [manipulated](../glossary.md#manipulate) during a run.


The output of the image execution can be shown to the user to convey detailed information on progress or errors.


#### Runtime manifest


The _runtime manifest_ MUST be represented by a valid `Dockerfile`, see Docker builder reference.


The file MUST be named `Dockerfile`.


The Dockerfile MUST contain the build instructions for the runtime environment and MUST have been used to create the image saved to the runtime image.
The build SHOULD be done with the option `--no-cache=true`.


The Dockerfile MUST NOT use the `latest` tag in the instruction `FROM`.


<div class="admonition note"><p class="admonition-title">Note</p><p>The "latest" tag is [merely a convention](http://container-solutions.com/docker-latest-confusion/) to denote the latest available image, so any tag can have undesired results.
Nevertheless, using an image tagged "latest" makes it much more likely to change over time.
Although there is no guarantee that images tagged differently, e.g. "v1.2.3" might not change as well, using such tags shall be enforced here.
</p></div>

The Dockerfile SHOULD contain the label `maintainer` to provide authorship information.


The Dockerfile MUST have an active instruction `CMD`, or a combination of the instructions `ENTRYPOINT` and `CMD`, which executes the packaged analysis.


The Dockerfile SHOULD NOT contain `EXPOSE` instructions.


#### Docker control statements


The control statements for Docker executions comprise `load`, for importing an image from the archive, and `run` for starting a container of the loaded image.
Both control statements MUST be configured by using nodes of the same name under the root-level node `execution` in the ERC configuration file.
Based on the configuration, an implementation can construct the respective run-time commands, i.e. [`docker load`](https://docs.docker.com/engine/reference/commandline/load/) and [`docker run`](https://docs.docker.com/engine/reference/run/), using the correct image file name and further parameters (e.g. performance control options).


<div class="admonition tip"><p class="admonition-title">Example</p><p>The following example shows default values for `image` and `manifest` and typical values for `run`.
</p></div>

    ```yml
    id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
    version: 1
    execution:
      image: image.tar.gz
      manifest: Dockerfile
      run:
        environment:
    	  - TZ=CET
    ```


<div class="admonition note"><p class="admonition-title">Note</p><p>The Docker CLI commands constructed based on this configuration by an implementing service could be as follows:
</p></div>

    ```bash
    docker load --input image.tar
    IMAGE_ID=$(docker images --filter "label=erc=b9b0099e-9f8d-4a33-8acf-cb0c062efaec" -q)
    docker run -it --name run_abc123 -e TZ=CET -v /storage/erc/abc123:/erc --label user:o2r $IMAGE_ID
	```


	In this case the implementation uses `-it` to pass stdout streams to the user and adds some metadata using `--name` and `--label`</code>`.


The only option for `load` is `quiet`, which may be set to Boolean `true` or `false`.


The only option for `run` is `environment` to set environment variables inside containers as defined in [docker-compose](https://docs.docker.com/compose/environment-variables/#setting-environment-variables-in-containers).
Environment variables are defined as a list separated by `=`.


<div class="admonition tip"><p class="admonition-title">Example for `load` and `run` properties</p><p>```yml
execution:
  load:
    quiet: true
  run:
    environment:
	  - DEBUG=1
	  - TZ=CET
```
</p></div>

The environment variables SHOULD be used to fix settings out of control of the contained code that can hinder successful ERC [checking](../glossary.md#check), e.g. by setting a time zone to avoid issues during checking.


The output of the container during execution MAY be shown to the user to convey detailed information to users.


#### Making data, code, and text available within container


The runtime environment image contains all dependencies and libraries needed by the code in an ERC.
Especially for large datasets, it in unfeasible to replicate the complete dataset contained within the ERC in the image.
For archival, it can also be confusing to replicate code and text, albeit them being relatively small in size, within the container.


Therefore a host directory is [mounted into a container](https://docs.docker.com/engine/reference/commandline/run/#mount-volume--v---read-only) at runtime using a [data volume](https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume).


The Dockerfile SHOULD NOT contain a `COPY` or `ADD` command to include data, code or text from the ERC into the image.


The Dockerfile MUST contain a `VOLUME` instruction to define the mount point of the ERC base directory within the container.
This mountpoint SHOULD be `/erc`.
Implementations MUST use this value as the default.
If the mountpoint is different from `/erc`, the value MUST be defined in `erc.yml` in a node `execution.mount_point`.


<div class="admonition tip"><p class="admonition-title">Example for mountpoint configuration</p><p>```yml
---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
execution:
  mount_point: "/erc"
```
</p></div>

<div class="admonition tip"><p class="admonition-title">Example Dockerfile</p><p>In this example we use a [_Rocker_](https://github.com/rocker-org/rocker) base image to reproduce computations made in R.
</p></div>

    ```Dockerfile
    FROM rocker/r-ver:3.3.3


    RUN apt-get update -qq \
    	&& apt-get install -y --no-install-recommends \
    	## Packages required by R extension packages
    	# required by rmarkdown:
    	lmodern \
    	pandoc \
    	# for devtools (requires git2r, httr):
    	libcurl4-openssl-dev \
    	libssl-dev \
    	git \
    	# for udunits:
    	libudunits2-0 \
    	libudunits2-dev \
    	# required when knitting the document
    	pandoc-citeproc \
    	&& apt-get clean \
    	&& rm -rf /var/lib/apt/lists/*


    # install R extension packages
    RUN install2.r -r "http://cran.rstudio.com" \
    	  rmarkdown \
    	  ggplot2 \
    	  devtools \
    	  && rm -rf /tmp/downloaded_packages/ /tmp/*.rd


    # Save installed packages to file
    RUN dpkg -l > /dpkg-list.txt


    LABEL maintainer=o2r \
      description="This is an ERC image." \
    	info.o2r.bag.id="123456"


    VOLUME ["/erc"]


    ENTRYPOINT ["sh", "-c"]
    CMD ["R --vanilla -e \"rmarkdown::render(input = '/erc/myPaper.rmd', output_dir = '/erc', output_format = rmarkdown::html_document())\""]
    ```


    See also: [Best practices for writing Dockerfiles](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run).


### R workspaces


#### Structure


The structure within the ERC contents directory are intentionally unspecified.
However, the contents structure MAY follow conventions or be based on templates for organizing research artifacts.


If a convention is followed then it SHOULD be referenced in the ERC configuration file as a node `convention` within the `structure` section.
The node's value can be any text string which uniquely identifies a convention, but a URI or URL to either a human-readable description or formal specification is RECOMMENDED.


A non-exhaustive list of potential conventions and guidelines _for R_ is as follows:


- [ROpenSci rrrpkg](https://github.com/ropensci/rrrpkg)
- [Jeff Hollister's manuscriptPackage](https://github.com/jhollist/manuscriptPackage)
- [Carl Boettiger's template](https://github.com/cboettig/template)
- [Francisco Rodriguez-Sanchez's template](https://github.com/Pakillo/template)
- [Ben Marwick's template](https://github.com/benmarwick/template)
- [Karl Broman's comments on reproducibility](http://kbroman.org/knitr_knutshell/pages/reproducible.html)


<div class="admonition tip"><p class="admonition-title">Example for using the ROPenSci `rrrpkg` convention</p><p>The convention is identified using the public link on GitHub.
```yml
---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
structure:
  convention: https://github.com/ropensci/rrrpkg
```
</p></div>

#### R Markdown main file


The ERC's _main file_ for R-based analyses SHOULD be [R Markdown](http://rmarkdown.rstudio.com/).


The main document SHOULD NOT contain code that loads pre-computed results from files, but conduct all analyses, even costly ones, during document weaving.


The document MUST NOT use `cache=TRUE` on any of the code chunks (see [`knitr` options](https://yihui.name/knitr/options/).
While the previously cached files (`.rdb` and `.rdx`) MAY be included, they SHOULD NOT be used during the rendering of the document.


<div class="admonition note"><p class="admonition-title">Note</p><p>A popular alternative solution is [Sweave](http://www.statistik.lmu.de/~leisch/Sweave/) with the `.Rnw` extension, which is still widely used for vignettes. R Markdown was chosen of LaTex for its simplicity for users who are unfamiliar with LaTeX.
</p></div>

#### Fixing the environment in code


The time zone MUST be fixed to `UTC` [Coordinated Universal Time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)) to allow validation of output times (potentially broken by different output formats) by using the following code within the RMarkdown document, or other code to that effect.


```r
Sys.setenv("TZ" = "UTC")
```


The manifest file (i.e. `Dockerfile`) MUST run a plain R session without loading `.RData` files or profiles at startup, i.e. use `R --vanilla`.


### Interactive ERC


Enabling interaction with the contents of an ERC is a crucial goal of this specification (see [Preface](#preface)).
Therefore this section defines metadata to support two goals:


- aide [inspecting](../glossary.md#inspect) users to identify core functions and parameters of an analysis, and
- allow supporting software tools to create interactive renderings of ERC contents for [manipulation](../glossary.md#manipulate).


These goals are manifested in the **UI bindings** as part of the ERC configuration file under the root level property `ui_bindings`.


An ERC MUST denote if UI bindings are present using the boolean property `interactive`.
If the property is missing it defaults to `false`.
An implementation MAY use the indicator `interactive: true` to provide other means of displaying the display file.


<div class="admonition tip"><p class="admonition-title">Example for minimal interaction configuration</p><p>```yml
---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
ui_bindings:
  interactive: true
```
</p></div>

An ERC MAY embed multiple concrete UI bindings.
Each UI binding is represented by a YAML dictionary.


It MUST comprise a purpose and a widget using the fields `purpose` respectively `widget` (both of type string).
The values of these fields SHOULD use a concept of an ontology to clearly identify their meaning.


A _purpose_ defines the user's intention, for example [manipulating](../glossary.md#manipulate) a variable or [inspecting](../glossary.md#inspect) dataset or code.
A _widget_ realizes the purpose with a concrete interaction paradigm chosen by the author, for example an input slider, a form field, or a button.


For each widget, implementations MAY use the properties `code`, `data`, and `text` to further describe how a specific UI binding acts upon the respective part of the ERC.


<div class="admonition tip"><p class="admonition-title">Example of two UI bindings</p><p>```yml
---
id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec
spec_version: 1
ui_bindings:
  interactive: true
  bindings:
    - purpose: http://.../data-inspection
      widget: http://.../tabular-browser
      code: [...]
      data: [...]
      text: [...]
    - purpose: http://.../parameter-manipulation
      widget: http://.../dropdown
```
</p></div>

### Preservation of ERC


This section places the ERC in the context of preservation workflows by defining structural information and other metadata that guarantee interpretability and enable the bundling of the complete ERC as a self-contained, archivable digital object.


#### Archival bundle


For the purpose of transferring and storing a complete ERC, it MUST be packaged using the [BagIt File Packaging Format (V0.97)][bagit] (BagIt) as the outer container.
BagIt allows to store and transfer arbitrary content along with minimal metadata as well as checksum based payload validation.


The remainder of this section comprises


- a description of the outer container,
- a BagIt profile,
- a package leaflet, and
- secondary metadata files.


##### BagIt outer container


The ERC base directory MUST be the BagIt payload directory `data/`.
The path to the ERC configuration file subsequently MUST be `<path-to-bag>/data/erc.yml`.


The bag metadata file `bagit.txt` MUST contain the case-sensitive label `Is-Executable-Research-Compendium` with the case-insensitive value `true` to mark the bag as the outer container of an ERC.


Implementations SHOULD use this field to identify an ERC.


<div class="admonition tip"><p class="admonition-title">Example `bagit.txt`</p><p>```txt
Payload-Oxum: 2172457623.43
Bagging-Date: 2016-02-01
Bag-Size: 2 GB
Is-Executable-Research-Compendium: true
```
</p></div>

<div class="admonition tip"><p class="admonition-title">Example file tree for a bagged ERC</p><p>```txt
&#9500;&#9472;&#9472; bag-info.txt
&#9500;&#9472;&#9472; bagit.txt
&#9500;&#9472;&#9472; data
&#9474;&#160;&#160; &#9500;&#9472;&#9472; 2016-07-17-sf2.Rmd
&#9474;&#160;&#160; &#9500;&#9472;&#9472; erc.yml
&#9474;&#160;&#160; &#9500;&#9472;&#9472; metadata.json
&#9474;&#160;&#160; &#9500;&#9472;&#9472; Dockerfile
&#9474;&#160;&#160; &#9492;&#9472;&#9472; image.tar
&#9500;&#9472;&#9472; manifest-md5.txt
&#9492;&#9472;&#9472; tagmanifest-md5.txt
```
</p></div>

##### BagIt profile


<div class="admonition note"><p class="admonition-title">Note</p><p>The elements of the o2r Bagit Profile is yet to be specified.
This section is under development.
Current BagIt tools do not include an option to add a BagIt Profile automatically.
</p></div>

A [BagIt Profile][bagitprofiles] as outlined below could make the requirements of this extension more explicit.
The BagIt Profiles Specification Draft allows users of BagIt bags to coordinate additional information, attached to bags.


```json
{
  "BagIt-Profile-Info":{
  "BagIt-Profile-Identifier":"http://o2r.info/erc-bagit-v1.json",
  "Source-Organization":"o2r.info",
  "Contact-Name":"o2r Team",
  "Contact-Email":"o2r@uni-muenster.de",
  "External-Description":"BagIt profile for packaging executable research compendia.",
  "Version":"1"
  },
  "Bag-Info":{
    "Contact-Name":{
       "required":true
    },
    "Contact-Email":{
       "required":true
    },
    "External-Identifier":{
       "required":true
    },
    "Bag-Size":{
       "required":true
    },
    "Payload-Oxum":{
       "required":true
    }
  },
  "Manifests-Required":[
    "md5"
  ],
  "Allow-Fetch.txt":false,
  "Serialization":"optional",
  "Accept-Serialization":[
     "application/zip"
  ],
  "Tag-Manifests-Required":[
    "md5"
  ],
  "Tag-Files-Required":[
     ".erc/metadata.json",
     ".erc.yml"
  ],
  "Accept-BagIt-Version":[
     "0.96"
  ]
}
```


[bagit]: http://tools.ietf.org/html/draft-kunze-bagit
[bagitprofiles]: https://github.com/ruebot/bagit-profiles



##### Package leaflet


Each ERC MUST contain a package leaflet, describing the schemas and standards used. Available schema files are supposed to be included with the ERC, if available (licenses for these schemas may apply).


<div class="admonition tip"><p class="admonition-title">Example package leaflet</p><p>```json
{
	"standards_used": [{
		"name": "DataCite Metadata Schema 4.0",
		"name-short": "datacite40",
		"description": "The DataCite Metadata Schema is a list of core metadata properties chosen for an accurate and consistent identification of a resource for citation and retrieval purposes, along with recommended use instructions.",
		"schema-version": "4.0",
		"schema-path-local": "erc/schema/datacite40.json ",
		"schema-url": "https://schema.datacite.org/meta/kernel-4.0/metadata.xsd",
		"schema-identifier": "doi:10.5438/0013"
	}, {
		"name": "Zenodo Metadata Schema",
		"name-short": "zenodo",
		"description": "The metadata schema applicable for zenodo 2017.",
		"schema-version": null,
		"schema-path-local": "erc/schema/zenodo.json ",
		"schema-url": null,
		"schema-identifier": null
	}]
}
```
</p></div>

Elements used for each schema / standard used:


- `name`: The name of the schema.
- `name-short`: The abbreviated name.
- `description`: The description of the schema.
- `schema-version`: The version of the schema as stated in the corresponding official schema file.
- `schema-path-local`: The path to the local version of the schema. It may point to a translated version of the original schema, e.g. json file from xml file.
- `schema-url`: The official URL of the schema file
- `schema-identifier`: The persistent identifier for the schema/standard.


##### Secondary metadata files


The ERC as an object can be used in a broad range of cases. For example, it can be an item under review during a journal publication, it can be the actual publication at a workshop or conference or it can be a preserved item in a digital archive. All of these have their own standards and requirements to apply, when it comes to metadata.


These metadata requirements _are not_ part of this specification, but the following conventions are made to simplify and coordinate the variety.


Metadata specific to a particular domain or use case MUST replicate the information required for the specific case in an independent file.
Domain metadata SHOULD follow domain conventions and standards regarding format and encoding of metadata.
Duplicate information is accepted, because it lowers the entry barrier for domain experts and systems, who can simply pick up a metadata copy in a format known to them.


Metadata documents of specific use cases MUST be stored in a directory `.erc`, which is a child-directory of the ERC base directory.


Metadata documents SHOULD be named according to the used standard or platform, and the used format respectively encoding, e.g. `datacite40.xml` or `zenodo_sandbox10.json`, and SHOULD use a suitable mime type.


###### Requirements of secondary metadata


In order to comply to their governing schemas, secondary metadata must include the mandatory information as set by 3rd party services. While the documentation of this quality is a perpetual task, we have gathered the information most relevant our selection of connected services.


**Zenodo**


+ Accepts metadata as `JSON`.
+ Mandatory elements:
	+ Upload Type (e.g. Publication)
	+ Publication Type
	+ Title
	+ Creators
	+ Description
	+ Publication Date
	+ Access Right
	+ License


**DataCite (4.0)**


+ Accepts metadata as `XML`.
+ Mandatory elements:
	+ Identifier
	+ Creator
	+ Title
	+ Publisher
	+ Publication Year
	+ Resource Type


Other third party standards that will be considered comprise: _CodeMeta_, _EuDat_, _mets/mods_.


#### Development bundle


While complete ERCs are focus of this specification, for collaboration and offline [inspection](../glossary.md#inspect) it is useful to provide access to parts of the ERC.
To support such use cases, a _development bundle_ MAY be provided by implementations.
This bundle most importantly would not include the _runtime image_, which is potentially a large file.


The _development bundle_ SHOULD always include the _main file_ and (e.g. by choice of the user, or by an implementing platform) MAY include other relevant files for reproduction or editing purposes outside of the runtime environment, such as input data or the _runtime manifest_ for manual environment recreation.


#### Content metadata _under development_


Current JSON dummy to visualise the properties. It SHOULD be filled out as good as possible.


```json
{
	"access_right": "open",
	"author": [{
		"name": null,
		"affiliation": [],
		"orcid": null
	}],
	"codefiles": [],
	"community": "o2r",
	"depends": [{
		"identifier": null,
		"version": null,
		"packageSystem": null
	}],
	"description": null,
	"ercIdentifier": null,
	"file": {
		"filename": null,
		"filepath": null,
		"mimetype": null
	},
	"generatedBy": null,
    "identifier": {
        "doi": null,
        "doiurl": null,
        "reserveddoi": null
    },
  "inputfiles": [],
	"keywords": [],
    "license": {"text": None,
            "data": None,
            "code": None,
            "uibindings": None,
            "md": None
            },
	"paperLanguage": [],
	"paperSource": null,
	"publicationDate": null,
	"recordDateCreated": null,
	"softwarePaperCitation": null,
	"spatial": {
		"files": [],
		"union": []
	},
	"temporal": {
		"begin": null,
		"end": null
	},
	"title": null,
    "upload_type": "publication",
    "viewfiles": []
}
```


The path to the o2r metadata file MUST be `<path-to-bag>/data/metadata.json`.


#### Description of metadata properties


Defining explanations on the concept of each metadata element in use.


+ `access_right` Modify embargo status, default is `open`.
+ `author` Contains a list of authors, each containing author related information.
+ `author.affiliation` A list of institutions, organizations or other groups that the creator of the asset is associated with.
+ `author.name` The name of the human individual, institution, organization, machine or other entity that acts as creator of the asset.
+ `author.orcid` The ORCid of the creator of the asset.
+ `codefiles` A list of files, containing programm code (i.e. script files, e.g. .R files) retrieved during the extraction.
+ `community` Indicates belonging to a scientific community, e.g. on a repositoy platform.
+ `depends` A block for each entity that the software is directly dependent on for execution. The dependency information is designed for the identification of dependent packages within packaging systems. A depends block may describe a transitive dependency.
+ `depends.identifier` An identifying name for the depending package.
+ `depends.version` The computer software and hardware required to run the software.
+ `depends.packageSystem` The package manager system that makes the dependency entity available.
+ `description` A text representation conveying the purpose and scope of the asset (the abstract).
+ `ercIdentifier` A universally unique character string associated with the asset as _executable research compendium_, provided by the o2r service.
+ `file` A block for the main source file for the metadata (e.g. rmd file), generated and used by the o2r service.
+ `file.filename` See above
+ `file.filepath` See above
+ `file.mimetype` See above
+ `generatedBy` The entity, person or tool, that created the software.
+ `identifier` Contains information related to persitent identifiers for the asset.
+ `identifier.doi` The DOI for the asset.
+ `identifier.doiurl` The resolving URL for the asset.
+ `identifier.reserveddoi` The assigned but inactive DOI for the asset. Might be minted by a repository during publication.
+ `inputfiles` A list of files that are loaded as resources by the main or code files of a workspace.
+ `interaction` Information on interactive elements in the asset.
+ `interaction.interactive` 'TRUE' if interactive elements are already included, otherwise 'FALSE'.
+ `interaction.ui_binding` A block for each UI binding - extends a figure by a UI widget, e.g. for manipulation. Final structure depends on purpose.
+ `interaction.ui_binding.purpose` What the UI binding is supposed to do.
+ `interaction.ui_binding.widget` Which UI widget realizes the purpose.
+ `interaction.ui_binding.code` A block containing source-code-specific information required to realize the UI binding.
+ `interaction.ui_binding.code.filename` Name of the file including the plot function that creates the figure.
+ `interaction.ui_binding.code.function` Name of the function that plots the figure.
+ `interaction.ui_binding.code.functionParameter` Parameters required by the shinyInputFunction. Final set of parameters depends on UI widget.
+ `interaction.ui_binding.variable` Variable that should be controlled by the UI widget.
+ `interaction.ui_binding.code.shinyInputFunction` Function that incorporates the UI widgets, provided by Shiny.
+ `interaction.ui_binding.code.shinyRenderFunction` Function that renders the plot after each change, provided by Shiny.
+ `keywords` Tags associated with the asset.
+ `license` License information for each part of the ERC.
+ `license.code` License for the code part of the ERC
+ `license.text` License for the text part of the ERC
+ `license.data` License for the data part of the ERC
+ `license.uibindings` License for the user interface bindings of the ERC
+ `license.md` License for the metadata of the ERC
+ `paperLanguage` A list of language codes that indicate the language of the asset, e.g. _en_.
+ `paperSource` The text document file of the paper.
+ `publicationDate` The publication date of the paper publication as [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) string.
+ `publication_type` The type of the publication. Default is `other` since the ERC may contain text, data, code and interaction widgets not depictable by other categories.
+ `recordDateCreated` The date that this metadata record was created as [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) string.
+ `softwarePaperCitation` Related citation information for the asset, e.g. a citation of the related journal article.
+ `spatial` Information about the geometric bounding box of the underlying data/software.
+ `spatial.files` A Geojson object of the file-wise bounding boxes of the underlying data/software.
+ `spatial.union` A Geojson object displaying the spatial properties, e.g. a bounding box of the whole data.
+ `temporal` Aggregated information about the relevant time period of the underlying data sets.
+ `temporal.begin` The starting point of the relevant time period.
+ `temporal.end` The end point of the relevant time period.
+ `title` The distinguishing name of the paper publication.
+ `upload_type` The zenodo upload type, default is `publication`. This element will be removed, once the target repository is completely configurabe within the o2r shipper micro service.
+ `view_file` The main display file.


### ERC checking


#### Procedure


A core feature ERCs are intended to support is comparing the output of an ERC executions with the original outputs.
Therefore [checking](../glossary.md#check) an ERC always comprises two steps: the execution and the comparison.


The files included in the comparison are the _comparison set_.
An implementation MUST communicate the comparison set to the user as part of a check.


Previous to the check, an implementation SHOULD conduct a basic validation of the outer container's integrity, i.e. check the file hashes.


#### Comparison set file


The ERC MAY contain a file named `.ercignore` in the base directory to define the comparison set.


Its purpose is to provide a way to efficiently exclude files and directories from [checking](../glossary.md#check).
If this file is present, any files and directories within the outer container which match the patterns within the file `.ercignore` will be excluded from the checking process.
The check MUST NOT fail when files listed in `.ercignore` are failing comparison.


The file MUST be UTF-8 (without BOM) encoded.
The newline-separated patterns in the file MUST be [Unix shell globs](https://en.wikipedia.org/wiki/Glob_(programming)).
For the purposes of matching, the root of the context is the ERC's base directory.


Lines starting with `#` are treated as comments and MUST be ignored by implementations.


<div class="admonition tip"><p class="admonition-title">Example `.ercignore` file</p><p>```bash
# comment
.erc
*/temp*
data-old/*
```
</p></div>

<div class="admonition note"><p class="admonition-title">Note</p><p>If using [md5](https://tools.ietf.org/html/rfc1321) file hashes for comparison, the set could include plain text files, for example the `text/*` [media types](https://en.wikipedia.org/wiki/Media_type) (see [IANA's full list of media types](https://www.iana.org/assignments/media-types/media-types.xhtml).
Of course the comparison set should include files which contain results of an analysis.
</p></div>

#### Comparing plain text documents


...


#### Comparing graphics and binary output


This section outlines possibilities beyond simple comparison and incorporates "harder" to compare files and what to do with them, e.g. plots/figures, PDFs, ...


### Security considerations


Why are ERC not a security risk?


[//]: # (take a look at https://tools.ietf.org/html/draft-kunze-bagit-14#section-6)


- the spec prohibits use of `EXPOSE`
- the containers are only executed _without_ external network access using `Network: none`, see [Docker CLI run documentation](https://docs.docker.com/engine/reference/run/#/network-none)


[c99-unspecified]: http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf#page=18
[rfc2119]: http://tools.ietf.org/html/rfc2119
[issues]: https://github.com/o2r-project/erc-spec/issues
[repo]: https://github.com/o2r-project/erc-spec
[rfc3986]: https://tools.ietf.org/html/rfc3986
[uuid]: https://en.wikipedia.org/wiki/Universally_unique_identifier



## User guide: ERC creation


This user guide comprises instructions how to create an ERC _by hand_.
It is thus limited to mandatory elements in some places.
However, a fundamental goal of the ERC specification is to be simple enough to allow manual ERC creation as demonstrated in this document.
It is supposed to ease the understanding of the ERC especially for the authors of scientific publications.
For using tools or services for creation and validation of ERCs, please see the developer guide.


<div class="admonition note"><p class="admonition-title">Note</p><p>This is a draft.
If you have comments or suggestions please file them in the .
If you have explicit changes please fork the  and submit a pull request.
</p></div>

### Step 1: create workspace


_Do your research and create something useful that works for you._
The ERC specification makes no restrictions on the contents of a workspace, but guidelines and best practices do exist and should be followed by users during their research i.e. even before packaging it in an ERC.


#### Code and versioning


If the base directory contains a script file or source code used to conduct the packaged analysis, we recommend this code is managed using [distributed version control](https://en.wikipedia.org/wiki/Distributed_version_control), see [software carpentry guidelines](https://github.com/swcarpentry/good-enough-practices-in-scientific-computing/blob/gh-pages/index.md#keeping-track-of-changes).
The base directory should contain a copy of the complete repository in that case.


#### Workspace structure


The base directory contents should follow common guidelines to project organisation.
Some useful resources are


- [Software carpentry paper "Good enough practices in Scientific Computing"](https://github.com/swcarpentry/good-enough-practices-in-scientific-computing/blob/gh-pages/index.md#project-organization)
- [ROpenSci research compendium](https://github.com/ropensci/rrrpkg)).
- [ROpenSci reproducibility guide](https://ropensci.github.io/reproducibility-guide/sections/introduction)


### Step 2: create image container for runtime


To create a working ERC you must include a complete environment description and an executable image.


We recommend using Docker, so a Dockerfile and a Docker image tarball archive file, to achieve these goals.


See the [runtime section](../spec/index.md#nested-runtime) for detailed requirements, including links to the relevant Docker commands.


### Step 3: create metadata


#### ERC metadata


Structural & administrative metadata must be put into the ERC configuration file `erc.yml` as defined in the [specification](../spec/index.md#erc-configuration-file).


When creating the erc manually, you can receive a uuid4 as `id` for the erc configuration file using an online service, e.g. [uuidgenerator](https://www.uuidgenerator.net/version4) or one of the numerous implementations for the common programming languages.


#### License metadata


Please consult your employer or legal department for a suitable license for your work. Make sure you hold the copyright for any code that you want to release under a self-chosen license.


Further resources that are linked here without any endorsement or being checked:


- [choosealicense.com](https://choosealicense.com) (for code)
- [opendefinition.org](http://opendefinition.org) (for code, data, text)
- [A short lecture on Open Licensing by Lorena A. Barba](https://speakerdeck.com/labarba/a-short-lecture-on-open-licensing)


License information must be put into the ERC configuration file `erc.yml` as defined in the [specification](../spec/index.md#erc-configuration-file).


#### Content metadata


Content metadata are used for making your work findable.
Properties for the content metadata are defined in the [specification](../spec/index.md#content-metadata) and must be put into the `metadata.json` file.


#### Secondary metadata


_As of now, we do not recommend creating secondary metadata by hand._


Secondary metadata are used for third party services, e.g. repositories that define their own obligatory metadata.
In general they can be added in different formats to support different use cases.


More information on secondary metadata can be found in the [preservation section](../spec/index.md#preservation-of-erc).



### Step 4: validate


You can use the container created in step 2 for validation purposes, too.
Run the analysis in the container, then copy the analysis output to a temporary directory on the host system, and finally compare the original workspace and the temporary directory according the [validation rules](../spec/index.md#validation) to ensure a complete replication.


### Step 5: create bag


To create a package that is suitable for being stored in an archive or repository, ERCs must be bundled as BagIt bags.
Take a look at the [preservation section](../spec/index.md#preservation-of-erc) for a detailed background about the purpose of BagIt and other digital preservation aspects.



#### Third party tools for creating BagIt bags


- [Bagger](https://github.com/LibraryOfCongress/bagger) (version 2.7, Java-based, with UI)
- [bagit-python](https://libraryofcongress.github.io/bagit-python/) (Python package)


#### Creating the bag


In this guide we will create the bag manually by using the Library of Congress's (LoC) tool _Bagger_, listed above.


1. Start by selecting "Create new bag" from the main menu and proceed with "&lt;no profile&gt;".
2. Add your files with the "+" Button.
3. Uncheck the "Standard" feature in the Bag-Info-Editor on the right and add `ERC-Version` with the appropriate version you want to use, e.g. `1`. Optionally fill out additional Bag-Info metadata, e.g. _contact information_.
4. Save your bag using the main menu.


#### Validating the bag


A file tree for the final bagged ERC may look like this:


```txt
├── bag-info.txt
├── bagit.txt
├── data
│   ├── 2016-07-17-myPaper.Rmd
│   ├── erc.yml
│   ├── metadata.json
│   ├── Dockerfile
│   └── image.tar
├── manifest-md5.txt
└── tagmanifest-md5.txt
```


You can validate your bag with _Bagger_ by loading the bag and then clicking on "Validate Bag" in the main menu.
The programme will check for completeness of BagIt-related files and verify the integrity of the data files by computing their checksums (hashes) and report any potential issues.


## User guide: ERC examination


TBD


## User guide: ERC template - WORK IN PROGRESS


If you want to create an ERC for your research already at the beginning, and not "post-hoc" after your research is complete, these templates can hopefully help.
They are divided into specific domains to be more concrete.


### Geoscience research in R


**Files in this template**


- `document.md` use RMarkdown, this is the main document
- `erc.yml` is template for the ERC configuration file with placeholders for all required fields
- `Dockerfile` is a template Dockerfile with some commands you can re-use to make sure all packages and tools that you need are installed


#### Header template


The yaml header of the `document.md` file is the right place to enter your meta information right away from the start: Fill out the metadata fields, included in the template, as early in your personal workflow as possible and keep them up-to-date to prepare for the ERC creation progress. The metadata extractor of the o2r service will collect and prefer information from RMarkdown document headers.


```yml
---
author:
  - name: Your Name
    affiliation: Your affiliation
    orcid: Your ORCid
  - name: Your co-author's name
    affiliation: Their affiliation
    orcid: Their ORCid
title: The title of your publication
abstract:
  A concise description of your publication
keywords: [lorem, ipsum, dolor, sit, amet]
date: 2017-01-13
license: cc-by
---
```





**Filename** | **Template** | **ERC-Spec**
------ | ------ | ------ |
[geo_template.zip](https://github.com/o2r-project/erc-spec/blob/master/templates/geo/geo_template.zip) | Geoscience research in R | V.1


## Minimal examples for ERCs


1. [R script with png plot](#r-script-with-png-plot)
1. [R Markdown with HTML output](#r-markdown-with-html-output)


### R script with png plot


#### Main file `main.R`


```R
## http://www.budgetshippingcontainers.co.uk/info/
## how-many-shipping-containers-are-there-in-the-world/
containers <- c(23000000,14000000,6000000)
set.seed(42)
barplot(containers,
    names.arg = c("in service", "ex-service", "new"),
    col = sample(colors(), 3),
    main = paste0(
        format(sum(containers), scientific = FALSE),
        " containers in the world")
    )
```


#### Display file `display.png`


![Minimal ERC example display.png](/img/minimal/display.png)


#### ERC configuration file


```yml
---
id: "289a9jcl9o"
spec_version: "1"
main: main.R
display: display.png
```




### R Markdown with HTML output


#### Main file `main.Rmd`


````markdown
---
title: "Capacity of container ships in seaborne trade from 1980 to 2016 (in million dwt)*"
author: "Daniel Nüst"
date: "2017"
output: html_document
---

```{r plot, echo=FALSE}

data <- c("1980" = 11, "1985" = 20, "1990" = 26, "1995" = 44,
          "2000" = 64, "2005" = 98, "2010" = 169, "2014" = 216,
          "2015" = 228, "2016" = 244)
barplot(data, ylab = "Capacity", sub = "© Statista 2017")
```


> This statistic portrays the capacity of the world container ship fleet from 1980 through 2016. In 2016, the world merchant container ship fleet had a capacity of around 244 million metric tons deadweight. As of January 2016, there were 5,239 container ships in the world's merchant fleet ([source](https://www.statista.com/statistics/264024/number-of-merchant-ships-worldwide-by-type/)).


Sources: UNCTAD; Clarkson Research Services, via [statista](https://www.statista.com/statistics/267603/capacity-of-container-ships-in-the-global-seaborne-trade/).
````


#### Display file `display.html`


<iframe src="/img/minimal/seaborne-trade.html" width="100%" height="500" style="border: 2px solid grey;"></iframe>


**[HTML](/img/minimal/seaborne-trade.html)**


#### ERC configuration file


```yml
---
id: "v97cplst6b"
spec_version: "1"
main: main.Rmd
display: display.html
```


## ERC preservation aspects in the light of OAIS


The Open Archival Information System (OAIS) reference model is a framework for the preservation and dissimination of digital objects (assets). It has been created by the Consultative Committee for Space Data Systems (CCSDS) and  has since been adopted by a wide range of international institutions. The OAIS provides the terminology and concept of the _information package_ as primitive of the digital preservation workflow. Submission information packages (SIP), Dissimination information packages (DIP) and Archival information packages (AIP) refer to different functional roles of a digital object during (long term) preservation.


The representation information object within OAIS consists of structural and semantic information and is itself linked to other units of representation information, building a representation network. The information contained within the ERC and its metadata serves as representation information and enables the interpretability of the archived software, environment, code, data, text and UI bindings. Standards used for representation are included as local copy of the underlying schema and as reference to their persistent identifiers. The network of information objects describes how the parts of the ERC relate to each other and how they are to be used and understood.



### References


- CCSDS (2012): RECOMMENDED PRACTICE FOR AN OAIS REFERENCE MODEL. CCSDS 650.0-M-2 (Magenta Book). [http://public.ccsds.org/publications/archive/650x0m2.pdf](http://public.ccsds.org/publications/archive/650x0m2.pdf)
- Maack, M.N. (2015). The Open Archival Information System (oais) Reference Model.


## User guide: the ERC as journal supplement


To facilitate integration into open access journals, the ERC can serve as a supplement for a journal article.
In that use case a supplement would not contain the full text of the publication but be attached to / linked from and article instead.
While this increases storage size (each ERC must contain all required data and software), introduces duplication (e.g. in the metadata) and spreads out related artifacts (e.g. if each supplement is stored in an independent repository item), it considerably simplifies integration with existing workflows and practices, e.g. by licensing and storing the supplemental material independently from the article, and by not impacting the existing article rendering solution (e.g. static HTML or PDF).


When the ERC is attached as supplement, it is important to make sure the results are still findable, accessible, interoperable, and reusable, following the FAIR principles.
A supplemental ERC should most importantly reference the main article via its DOI.


An ERC as supplement must still be a formally complete ERC and as such it satisfies important requirements of reproducible research.


<div class="admonition tip"><p class="admonition-title">Example</p><p>A publication contains three figures with data plots.
Two approaches are possible:
</p></div>

    - each of the figures is encapsulated in a minimal ERC containing the needed data, an R script, the rendered figure as a grphic (e.g. a PNG), and its own runtime environment; or
    - all figures are embedded in an R Markdown document, including the article abstract, figure titles, and figure description, and share data files and the runtime environment.


    The latter approach is more user friendly because explanatory context is provided and the HTML-based display file directly supports UI bindings.


Read more on the increasing importance of reproducible supplements scientific records in
[Greenbaum et al. 2017](https://doi.org/10.1186/s13059-017-1205-3).


## ERC developer guide


An introduction to the ERC rational and the technology choices made within the project _Opening Reproducible Research_, and ideas for downstream products based on ERCs.
This documents is targeted at developers who wish to create tools for creating, validating, and consuming ERC.


<div class="admonition note"><p class="admonition-title">Note</p><p>This guide is a draft. If you have comments or suggestions please file them in the . If you have explicit changes please fork the  and submit a pull request.
</p></div>

### Convention over configuration and DevOps


The ERC specification is inspired by two approaches to improve development and operation of software.
First,  [_"convention  over  configuration"_](https://en.wikipedia.org/wiki/Convention_over_configuration), e.g. as  practiced  in  the Java build tool [Maven](https://books.sonatype.com/mvnref-book/reference/installation-sect-conventionConfiguration.html).


We want to create a directory structure with default file names and sensible defaults.
This way a typical research workspace should require only minimal configuration in 80% of the cases, while allowing to override each of the settings if need be and providing full customizability in the remaining 20%.


For example, the main command to compile the text manuscript in a bagtainer could be `knitr::knit("<*>.Rmd")`, with `<*>` being replaced by name of the first RMarkdown file.
However, if a user wants to use `rmarkdown::render(..)` on a file named `publication.md`, then the default behaviour can be overwritten.


Second, _"DevOps"_, see [Wikipedia](https://en.wikipedia.org/wiki/DevOps) or [Boettiger](https://doi.org/10.1145/2723872.2723882).
All processing and configuration shall be scripted, no "click" interaction required.


### Reasoning and decisions


#### Some observations


- researchers do their thing and need independence/flexibility, so post-hoc creation will probably be most common and ERC must have low to no impact on workflow
- data storage, citation and preservation is solved (repos, bitstream preservation in archives)
- packaging methods/methodology is solved (R packages, Python packages, ...)
- software preservation is _not_ solved (methods are there, like migration, emulation, but complexity is too high to do this at high granularity)
- reproducible paper is solved (literate programming, R package dependency handling solutions, ..)
- computational RR requires sandboxing (to make sure everything is there as much as security)
- a service is needed to create ERC for researchers and executes them in a controlled environment


#### Why nested containers


A user shall have access to the files without starting the runtime container.
Therefore we have at least two items, so we have a bundle and need an outer container.
As a bonus, the outer container can immediately be used to make an ERC conform to specific use cases, such as long term archival.
Also the chosen outer container standard is much older and common than the inner container standard, and thus more likely to exist longer.


The alternative of putting everything into the container itself (e.g. using image labels for metadata) can be evaluated in the future.


#### Why BagIt


...


#### Why Docker


- (Docker) containers provide an encapsulation mechanism to package all dependencies of an anylsis
- during container execution, and substitution, the build in [copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write) storage only creates copy of files that are changed within the container, thus saving storage capacity
- volume mounts allow easy substitution of input data and configurations of analysis


#### Why not Singularity


[Singularity](http://singularity.lbl.gov/) is an open source containerization solution.
It might very well be a better choice for reproducible research in the future as it stems from the scientific community (HPC), cf. also [C4RR workshop 2017](https://www.software.ac.uk/c4rr).
At the point of starting the specification, Docker was more widespread and implementations more readily available.
Furthermore the origin of Singularity, high performance computing, is out of scope of ERC.


We do not see an issue in not using Singulary.
Most importantly, the concepts _runtime manifest_ and _runtime image_ are abstract, i.e. independent of Docker and the concrete container tool choice could be made flexible in future versions of the specification.
Singularity can import Docker images and as such make a transition possible, or even let an implementation use Singularity without touch the specification.


#### Why not just use plain R?


It would be possible to rely solely on R for replication.
For example, the runtime manifest could be a [codemeta](https://codemeta.github.io/) document, and the runtime environment is created based on it outside of the ERC when needed, for example by installing R in the required version.
Additionally a package for preserving a state of dependencies could be used, e.g. [packrat](https://rstudio.github.io/packrat/).
This solution is potentially less storage intensive, because containers replicate an R installation each time.
Smaller storages might also ease collaboration.


However, none of these solutions touches the underlying system libraries.
The complexity of preserving the runtime environment is transferred from the packaging stage to the unpackaging stage, which is unfavourable because that packaging state "everything works", so better control is ensured at that time.
The burden in a plain R solution shifts from authoring to preservation.


Even though shipping system binaries within packages is possible (if not common), some packages do use system libraries which are not preserved in a plain R approach.
Adjusting such packages is not an option.


Furthermore, none of the solutions for reproducibility are part of "core R", even if they are trustworthy (e.g. MRAN). CRAN does not support installing specific package versions.


That is why using an abstraction layer outside of R is preferable.


#### Licensing information


Without proper license credits, the contents of an ERC would be useless based on today's copyright laws.
Therefore we rather have the extra work for authors to define a license than to create something that is unusable by others.


One of the biggest issues is the **scope of licenses**, namely what to do about having multiple pieces of code, text, or data with different licenses.


#### Put the identifier into the ERC


- makes it easier to track across platforms
- is harder for manual creation


#### Why use bash


While it is true that..


> "What's oldest lasts longest." [via](https://github.com/swcarpentry/good-enough-practices-in-scientific-computing/blob/gh-pages/index.md#supplementary-materials)


using containers gives the necessary abstraction and encapsulation, so simply using bash (or make) does not suffice.


#### Why is validation happening outside the container and not _in_ the container


- better user experience (otherwise all info must be transported via stdout)
- to be sure nothing is manipulated within the validation script


#### Why is the data not in the image (inner container) but in the outer container


- better accessible in the long term
- no data duplication


### o2r Platform


The software developed by the o2r project is the reference implementation of the ERC specification.


#### Web API


[o2r Web API specification](http://o2r.info/o2r-web-api)


#### Architecture


[o2r Architecture documentation](http://o2r.info/architecture/)


### ERC completeness score


While the ERC is intended to be simple enough to be created manually, the clear requirements on it's contents also serve a semi-automatic creation.
For example, a user can upload a workspace with data files, and R Markdown document, and an HTML rendering of the document to an online platform, where the runtime manifest and image are automatically created. In such a case, metadata would still be added manually.


To encourage users, especially during the manual steps of the creation process, to provide valuable input a **completeness score** can be useful.
Comparable to profile editors on social network sites, a percentage based score can be used to highlight content or aspects going beyond the mandatory requirements.


Implementing platforms may create their own rules, for example which of the optional metadata elements contribute towards reaching a full score.
Thinking beyond merely the metadata, the score could also cover the runtime manifest (e.g. does it follow common practices, include relevant independent metadata, uses explicit versioning for dependency installation), contained code (e.g. automatic checks against code formatting guidelines, syntactical errors), and contained data (e.g. are open file formats used, maybe rewarding CSV over Shapefiles).


A completeness score can be seen as a _downstream product_ based on the ERC.
It is unlikely this ever makes it into an ERC specification, but it can be a crucial means towards acceptance, adoption, and success of ERCs.


## Glossary


### (Computational) Analysis


A scientific workflow that is to be preserved in an ERC.
It conducts a number of operations on data and generates an output (text, numbers, plots).


### Bag


See [BagIt specification](https://tools.ietf.org/html/draft-kunze-bagit).


> A set of opaque data contained within the structure defined by this specification.


### Compendium contents


See [ERC contents](#erc-contents)


### Container


A receptacle holding a collection of things ("payload" or "contents").
In the context of this specification, several containers are distinguished: [runtime container](#runtime-container) (with [Docker container](#docker-container) as a concrete instance) and [outer container](#outer-container).


### Check


A subconstituent of [_Examine_](#examine).
Checking an ERC is a syntactical validation, which may be largely automated by a software tool reporting the check result and potential errors.
A check comprises (a) the validation of a concrete ERC against the ERC specification, e.g. are required files and metadata fields present, and (b) an execution of the contained analysis.
The execution includes a comparison of the result files in the just executed inner container with the result stored in the outer container.


### Create


One of the major constituents of ERC interaction.
The user can create an ERC by following the technical instructions included in the Specification (ERC Spec) or use the o2r reproducibility service, which has been referentially implemented as "o2r platform".
For more information, see [erc-spec/user-guide/creation/]


### Discover


One of the major constituents of ERC interaction.
Discovery comprises the findability of the ERC as well as the exploration of its features, e.g. time and space driven search operations.


### Docker container


TBD


### ERC


Executable Research Compendium, see [this article](https://doi.org/10.1045/january2017-nuest)


### ERC contents


See [workspace](#workspace).


### ERC metadata


Schema compliant information about the ERC, its contents and creators.


### Examine


One of the major constituents of ERC interaction.
It comprises _Check_, _Inspect_, _Manipulate_ and _Substitute_.
To examine an ERC means to explore its contents in depth, i.e. check the reproduced version, inspect text, code and data, manipulate interactive elements, as well as exchange input data.


### Inner container


See [runtime container](#runtime-container)


### Inspect


A subconstituent of [_Examine_](#examine).
Inspection includes looking at all the contents of an ERC, such as code or data files, and metadata documents.
A user conducting inspection evaluates the meaning of the ERC's artifacts.


### Display file


The file in the container that a reader software uses as the first display to a user to read text and explore graphics.
The entry point for [examination](#examine).


### Manipulate


A subconstituent of [_Examine_](#examine).
A manipulation comprises interactive changing of selected, pre-defined parameters that influence the computation packaged in an ERC.
For example, the number of layers in a neural network, the size/selection method of the training dataset in supervised machine learning, or the variogram model of geostatistical kriging.
These parameters are defined via [UI bindings](#ui-bindings).


### OAIS


The [Open Archival Information System](https://en.wikipedia.org/wiki/Open_Archival_Information_System) and its [reference model](https://web.archive.org/web/20131020200910/http://public.ccsds.org/publications/archive/650x0m2.pdf).


### Outer container


Term used to distinguish the "outer" [Bag](#bag) from the embedded [runtime container](#runtime-container).


### Reproducible, Reproducibility, Replication


See [section 2.1 "Definition of Reproducibility"](https://doi.org/10.1045/january2017-nuest).


### Runtime container


TBD


### Substitute


A subconstituent of [_Examine_](#examine).
During a substitution, compatible parts of an ERC are exchanged, e.g. similar data sets for a given analysis, or exchanging an analysis script.
A substution process usually creates a new ERC based on two input ERCs: the _base ERC_ and the _overlay ERC_.
One or several data or code files from the _overlay ERC_ replace corresponding files in the _base ERC_, to create a new ERC.


### UI bindings


TBD


### Workspace


The files created by the author of the original analysis, packages together with ERC metadata in the [outer container](#outer-container).


## Support


If you have questions about the ERC specification and its usage which are not answered by the [user and developer guides](index.md#guides), feel free to contact us using the options below.


### Email


[daniel.nuest@uni-muenster.de](mailto:daniel.nuest@uni-muenster.de?Subject=ERC%20specification)


### Discussion forum


<div id="disqus_thread" style="margin:auto; width:auto; text-align=center"></div>
<script>
    var disqus_config = function () {
        this.page.url = "http://o2r.info/erc-spec/support";
        this.page.identifier = "erc-spec-support";
    };
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//o2r-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<script id="dsq-count-scr" src="//o2r-blog.disqus.com/count.js" async></script>
<noscript>Please enable JavaScript to view the </noscript>



