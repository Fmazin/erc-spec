{
    "docs": [
        {
            "location": "/",
            "text": "\\newpage\n\n\nExecutable Research Compendium\n\u00b6\n\n\nThis is the technical specification of the Executable Research Compendium (ERC).\n\n\nRead the \nspecification\n (\nPDF download\n) and \nget \nsupport\n.\n\n\nGuides\n\u00b6\n\n\nAre you a \nscientist\n and want to publish your research as an ERC? Read \nuser guides for authors\n:\n\n\n\n\nERC creation\n\n\nERC examination\n\n\nERC template\n\n\n\n\nAre you a \ndeveloper\n and want to build applications for ERCs? Read \nuser guides for developers\n:\n\n\n\n\nDeveloper guide\n\n\n\n\nAre your a \nlibrarian\n or \npreservationist\n and want to use ERCs for archival of scholarly works? Read \nuser guides for librarians and preservationists\n:\n\n\n\n\nERC & OAIS\n\n\n\n\n\\newpage\n\n\nCredits\n\u00b6\n\n\nThis specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research\n\n\n\n\nLicense\n\u00b6\n\n\n\n\nThe o2r Executable Research Compendium specification is licensed under \nCreative Commons CC0 1.0 Universal License\n, see file \nLICENSE\n.\nTo the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work.\nThis work is published from: Germany.\n\n\nBuild @@VERSION@@ @ @@TIMESTAMP@@",
            "title": "Home"
        },
        {
            "location": "/#executable-research-compendium",
            "text": "This is the technical specification of the Executable Research Compendium (ERC).  Read the  specification  ( PDF download ) and  get  support .",
            "title": "Executable Research Compendium"
        },
        {
            "location": "/#guides",
            "text": "Are you a  scientist  and want to publish your research as an ERC? Read  user guides for authors :   ERC creation  ERC examination  ERC template   Are you a  developer  and want to build applications for ERCs? Read  user guides for developers :   Developer guide   Are your a  librarian  or  preservationist  and want to use ERCs for archival of scholarly works? Read  user guides for librarians and preservationists :   ERC & OAIS   \\newpage",
            "title": "Guides"
        },
        {
            "location": "/#credits",
            "text": "This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research",
            "title": "Credits"
        },
        {
            "location": "/#license",
            "text": "The o2r Executable Research Compendium specification is licensed under  Creative Commons CC0 1.0 Universal License , see file  LICENSE .\nTo the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work.\nThis work is published from: Germany.  Build @@VERSION@@ @ @@TIMESTAMP@@",
            "title": "License"
        },
        {
            "location": "/spec/",
            "text": "\\newpage\n\n\nERC specification\n\u00b6\n\n\nAn Executable Research Compendium (ERC) is a packaging convention for computational research.\nIt provides a well-defined structure for data, code, text, documentation, and user interface controls for a piece of research and is suitable for long-term archival. As such it can also be perceived as a digital object or asset.\n\n\n\n\nNote\n\n\nThis is a draft specification. If you have comments or suggestions please file them in the \nissue tracker\n. If you have explicit changes please fork the \ngit repo\n and submit a pull request.\n\n\n\n\nPreface\n\u00b6\n\n\nVersion\n\u00b6\n\n\nSpecification version: \n1\n\n\n\n\nWarning\n\n\nThis version is \nunder development\n!\n\n\n\n\nNotational conventions\n\u00b6\n\n\nThe key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d are to be interpreted as described in \nRFC 2119\n.\n\n\nThe key words \u201cunspecified\u201d, \u201cundefined\u201d, and \u201cimplementation-defined\u201d are to be interpreted as described in the \nrationale for the C99 standard\n.\n\n\nPurpose, target audience, and context\n\u00b6\n\n\nThis specification defines a structure to transport and execute a computational scientific analysis (cf. \ncomputational science\n).\nIt carries technical and conceptual details on how to implement tools to enhance reproducibility and is most suitable \nfor developers\n.\n\nAuthors\n may feel more comfortable with the \nuser guides\n.\n\n\nThese analyses typically comprise a digital workspace on a researcher\u2019s computer, which contains \ndata\n (\nborn digital\n, simulated, or other), \ncode\n, third party \nsoftware\n or libraries, and \noutputs\n of research such as digital plots or data.\nCode and libraries are required in executable form to re-do a specific analysis or workflow.\nResearch is only put into a context by a \ntext\n, e.g. a research paper, which is published in \nscholarly communication\n.\nThe text comes in two forms: one that is machine readable, and another one that is suitable for being viewed by humans.\nThe latter is derived, or \u201crendered\u201d, from the former.\nThe viewing experience can be static, textual, visual, or interactive.\n\n\nPutting all of these elements in a self-contained bundle allows examining, reproducing, transferring, archiving, and formally validating computational research results in a time frame for peer review and collaboration.\nThe ERC specification defines metadata and file structures to support these actions.\n\n\nMajor constituents\n\u00b6\n\n\nThree major constituents group possible user interactions with ERC.\n\n\n\n\nCreate\n\n\nCreation\n is transforming a workspace with data, code and text into an ERC.\n\n\nExamine\n\n\nExamination\n is evaluating ERC at different levels, from inspecting contents to creating derived analyses.\n\n\nDiscover\n\n\nDiscovery\n is searching for content powered by ERC properties, such as text, content metadata, code metadata et cetera.\n\n\n\n\nDesign principles\n\u00b6\n\n\n\n\nSimplicity\n\n\nThis specification should not re-do something which already exists (if it is an open specification or tool).\n  The risk of scattering information is mitigated by clear documentation. \n  It must be possible to create a valid and working ERC \nmanually\n, while supporting tools should be able to cover typical use cases with minimal required input by a creating user.\n\n\nNested containers\n\n\nWe acknowledge well defined standards for packaging a set of files, and different approaches to create an executable code package.\n  Therefore an ERC comprises \none or more containers but is itself subject to being put into a container\n.\n  We distinguish these containers into the inner or \u201cruntime\u201d container and the outer container, which is used for transfer of complete ERC and not content-aware validation.\n\n\nTransparency, Stability, and Openness\n\n\nPlain text files usable by both humans and computers are the backbone to make sure ERCs are acceptable by users from all scientific domains, are understandable today and tomorrow, and are easy to extend.\n  The ERC contains everything needed to execute a workflow.\n\n\n\n\nHow to use an ERC\n\u00b6\n\n\nThe steps to (re-)run the analysis contained in an ERC as part of an \nexamination\n are as follows:\n\n\n\n\n(if compressed first extract then) unpack the ERC\u2019s outer container\n\n\nexecute the runtime container\n\n\ncompare the output files contained in the outer container with the output files just created by the runtime container\n\n\n\n\nThis way an ERC allows computational reproducibility based on the original code and data.\n\n\nThree questions\n\u00b6\n\n\n[Section inspired by \nREANA\u2019s \u201cFour Questions\u201d\n]\n\n\nThe ERC helps to make research papers more transparent an reusable by giving minimal structure for contents and context.\nThey help to answer the \u201cThree Questions\u201d both for users, but more importantly for tools and services built around them.\n\n\n\n\nWhat is your result?\n\n\nfile I should look at to see the description and visualisations\n\n\nthe \u201cdisplay file\u201d shown by applications based on ERC\n\n\n\n\n\n\nWhat is your workflow?\n\n\nfile I should look at as a reader when I want to understand your code/analysis/workflow, the steps you took\n\n\nthe \u201cmain file\u201d used by applications based on ERC for creating ERCs and executing them, which means running the analysis and creating the result\n\n\n\n\n\n\nWhat is your environment?\n\n\noperating system you used\n\n\nsoftware you used (libraries, your own scripts, \u2026)\n\n\ncan be used by tools to recreate the same environment\n\n\n\n\n\n\n\n\nERC structure\n\u00b6\n\n\nBase directory\n\u00b6\n\n\nAn ERC MUST has a \nbase directory\n. All paths within this document are relative to this base directory.\n\n\nThe base directory MUST contain an \nERC configuration file\n.\n\n\nBesides the files mentioned in this specification, the base directory MAY contain any other files and directories.\n\n\nMain & display file\n\u00b6\n\n\nAn ERC MUST have a \nmain file, i.e. the file which contains the text and instructions being the basis for the scientific publication describing the packaged analysis.\nAn ERC MUST have a _display file\n, i.e. the file which is shown to a user first when she opens an ERC in a supporting platform or tool.\n\n\nMain file\n and \ndisplay file\n MUST NOT be the same file.\n\n\nThe \nmain file\n MUST be \nexecutable\n in the sense that a software reads it as the input of a process to create the \ndisplay file\n.\nThe \nmain file\n\u2018s name SHOULD be \nmain\n with an appropriate file extension and \nmedia type\n.\n\n\n\n\nNote\n\n\nThe \nmain file\n thus follows the \nliterate programming paradigm\n.\n\n\n\n\n\n\nExample\n\n\nIf the main file is an R Markdown document, then the file extension should be \n.Rmd\n and the media type \ntext/markdown\n.\nA file \nmain.Rmd\n will consequently be automatically identified by an implementation as the ERC\u2019s \nmain file\n.\n\n\n\n\nThe display file\u2019s name SHOULD be \ndisplay\n with an appropriate file extension and media type.\n\n\n\n\nExample\n\n\nIf the display file is an Hypertext Markup Language (HTML) document, then the file extension should be \n.htm\n or \n.html\n and the media type \ntext/html\n.\nA file \ndisplay.html\n will consequently be automatically identified by an implementation as the ERC\u2019s \ndisplay file\n.\n\n\n\n\nThe ERC MAY use an interactive document with interactive figures and control elements for the packaged computations as the \ndisplay file\n.\nThe \ninteractive display file\n MUST have \nHTML\n format and SHOULD be valid \nHTML5\n.\n\n\n\n\nExample\n\n\nTypical examples for the two core documents are R Markdown with HTML output (i.e. \nmain.Rmd\n and \ndisplay.html\n), or an \nR\n script creating a PNG file (i.e. \nmain.R\n and \ndisplay.png\n).\n\n\n\n\nNested runtime\n\u00b6\n\n\nThe embedding of a representation of the original runtime environment, in which the analysis was conducted, is crucial for supporting reproducible computations.\nEvery ERC MUST include two such such representations:\n\n\n\n\nan \nexecutable runtime image\n of the original analysis environment for re-running the packaged analysis, and \n\n\na \nruntime manifest\n documenting the image\u2019s contents as a complete, self-consistent recipe of the runtime image\u2019s contents which is a machine-readable format that allows a respective tool to create the runtime image.\n\n\n\n\nThe image MUST be stored as a file, e.g. a \u201cbinary\u201d or \u201carchive\u201d, in the ERC base directory.\n\n\nThe manifest MUST be stored as a text file in the ERC base directory.\n\n\nSystem environment\n\n\nThe nested runtime encapsulates software, files, and configurations up to a specific level of abstraction.\nIt may not include a complete operating system, for example for better performance or security reasons.\nWhile this information is included in the nested runtime, it MUST be accessible without executing the runtime.\nHard to obtain information SHOULD be replicated in the configuration file.\n\n\nIf the nested runtime does not include the operating system, then the configuration file MUST include the following data about the environment used to create the ERC:\n\n\n\n\narchitecture\n\n\noperating system\n\n\nkernel\n (if applicable)\n\n\nruntime software version\n\n\n\n\nAn implementation SHOULD notify the user if the provided system environment is incompatible with the implementations capabilities.\n\n\n\n\nTip\n\n\nA partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare.\nAn implementation may utilise \nsemantic versioning\n to improve its compatibility tests.\nAn incompatible operating system, e.g. \nlinux\n vs. \nwindows\n, and architecture, e.g. \namd64\n or \narm/v7\n, are likely to fail.\n\n\n\n\nERC configuration file\n\u00b6\n\n\nThe ERC configuration file is the \nreproducibility manifest\n for an ERC. It defines the main entry points for actions performed on an ERC and core metadata elements.\n\n\nName, format, and encoding\n\u00b6\n\n\nThe filename MUST be \nerc.yml\n and it MUST be located in the base directory.\nThe contents MUST be valid \nYAML 1.2\n.\nThe file MUST be encoded in \nUTF-8\n and MUST NOT contain a byte-order mark (BOM).\n\n\nBasic fields\n\u00b6\n\n\nThe first document content of this file MUST contain the following string nodes at the root level.\n\n\n\n\nspec_version\n: a text string noting the version of the used ERC specification. The appropriate version for an ERC conforming to this version of the specification is \n1\n.\n\n\nid\n: globally unique identifier for a specific ERC. \nid\n MUST not be empty and MUST only contain lowercase letters, uppercase letters, digits and single separators. Valid separators are period, underscore, or dash. A name component MUST NOT start or end with a separator. An implementation MAY introduce further restrictions on minimum and maximum length of identifiers.\n\n\n\n\n\n\nNote\n\n\nWhile URIs (see \nrfc3986\n) are very common identifiers, not all systems support them as identifiers.\nFor example they cannot be used for Docker image names.\nA \nUUID\n is a valid \nid\n.\nA regular expression to validate identifiers is \n/^[^-_.][a-zA-Z0-9._-]+[^-_.]$/\n.\n\n\n\n\nThe main and display file MAY be defined in root-level nodes named \nmain\n and \ndisplay\n respectively.\nIf they are not defined and multiple documents use the name \nmain.[ext]\n or \ndisplay.[ext]\n, an implementation SHOULD use the first file in \nalphabetical order\n.\n\n\n\n\nExample of ERC configuration file with user-defined main and display files\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nmain: workflow.Rmd\ndisplay: paper.html\n\n\n\n\n\nAdditionally, related resources such as a related publication can be stated with the \nrelatedIdentifier\n element field.\nA related identifier SHOULD be a globally unique persistent identifier and SHOULD be a URI.\n\n\nAuthor and license metadata\n\u00b6\n\n\nThe main document MUST include information about the authors.\nIt SHOULD contain this information in a structured way so it can be parsed by tools supporting ERCs.\n\n\nThe file \nerc.yml\n MUST contain a first level node \nlicenses\n with licensing information for contained artefacts.\nEach of these artefacts, e.g. code or data, have distinct requirements so it must be possible to apply different licenses.\n\n\nThe node \nlicenses\n MUST have five child nodes: \ntext\n, \ndata\n, \ncode\n, \nui_bindings\n, and \nmetadata\n.\n\n\n\n\nNote\n\n\nThere is currently no mechanism to define the licenses of all the used libraries and software in a structured format.\nManual creation would be tedious.\nTools for automatic creation of ERC may add such detailed licensing information and define additional metadata elements.\n\n\n\n\nThe content of each of these child nodes MUST be a string with one of the following contents:\n\n\n\n\nlicense identifier\n as defined by the \nOpen Definition Licenses Service\n\n\nname of file\n with either documentation on licensing or a full license text\n\n\n\n\n\n\nExample for common licenses\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n    code: Apache-2.0\n    data: ODbL-1.0\n    text: CC0-1.0\n    ui_bindings: CC0-1.0\n    metadata: CC0-1.0\n\n\n\n\n\n\n\nExample for non-standard licenses\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n    code: Apache-2.0\n    data: data-licenses.txt\n    text: \"Creative Commons Attribution 2.0 Generic (CC BY 2.0)\"\n    ui_bindings: CC0-1.0\n    metadata: \"see metadata license headers\"\n\n\n\n\n\nRuntime manifest and image\n\u00b6\n\n\nThe ERC uses \nDocker\n to define, build, and store the nested runtime environment.\n\n\nRuntime image\n\u00b6\n\n\nThe \nruntime environment or image\n MUST be represented by a \nDocker image \nv1.2.0\n.\n\n\n\n\nNote\n\n\nA concrete implementation of ERC may choose to rely on constructing the runtime environment from the manifest when needed, e.g. for export to a repository, while the ERC is constructed.\n\n\n\n\nThe base directory MUST contain a \ntarball\n, i.e. an archive file, of a Docker image as created be the command \ndocker save\n, see \nDocker CLI save command documentation\n, as defined in version \n1.12.x\n.\n\n\nThe image MUST have a tag \nerc:<erc identifier>\n, for example \nerc:b9b0099e-9f8d-4a33-8acf-cb0c062efaec\n.\n\n\nThe image file MAY be compressed.\n\n\nThe image archive file name MUST be \nimage\n with an appropriate file extension, such as \n.tar\n, \n.tar.gz\n (if a \ngzip compression is used for the archive\n) or \n.bin\n, and have an appropriate mime type, e.g. \napplication/vnd.oci.image.layer.tar+gzip\n.\n\n\n\n\nNote\n\n\nBefore exporting the Docker image, it should be \nbuild\n from the runtime manifest, including the tag which can be used to identify the image, for example:\n\ndocker build --tag erc:b9b0099e-9f8d .\ndocker images erc:b9b0099e-9f8d\ndocker save erc:b9b0099e-9f8d > image.tar\n# save with compression:\ndocker save erc:b9b0099e-9f8d | gzip -c > image.tar.gz\n\nDo \nnot\n use \ndocker export\n, because it is used to create a snapshot of a container, which must not match the Dockerfile anymore as it may have been \nmanipulated\n during a run.\n\n\n\n\nRuntime manifest\n\u00b6\n\n\nThe \nruntime manifest\n MUST be represented by a valid \nDockerfile\n, see \nDocker builder reference\n, as defined in version \n1.12.x\n.\n\n\nThe file MUST be named \nDockerfile\n.\n\n\nThe Dockerfile MUST contain the build instructions for the runtime environment and MUST have been used to create the image saved to the \nruntime image\n using \ndocker build\n, see \nDocker CLI build command documentation\n, as defined in version \n1.12.x\n.\nThe build SHOULD be done with the option \n--no-cache=true\n.\n\n\nThe Dockerfile MUST NOT use the \nlatest\n tag in the instruction \nFROM\n.\n\n\n\n\nNote\n\n\nThe \u201clatest\u201d tag is \nmerely a convention\n to denote the latest available image, so any tag can have undesired results.\nNevertheless, using an image tagged \u201clatest\u201d makes it much more likely to change over time.\nAlthough there is no guarantee that images tagged differently, e.g. \u201cv1.2.3\u201d might not change as well, using such tags shall be enforced here.\n\n\n\n\nThe Dockerfile SHOULD contain the \nlabel \nmaintainer\n to provide authorship information.\n\n\nThe Dockerfile MUST have an active instruction \nCMD\n, or a combination of the instructions \nENTRYPOINT\n and \nCMD\n, which executes the packaged analysis.\n\n\nThe Dockerfile SHOULD NOT contain \nEXPOSE\n instructions.\n\n\nSystem environment\n\u00b6\n\n\nThe following \nsystem environment configurations\n MUST be provided as nodes under the root-level node \nexecution\n:\n\n\n\n\n(if applicable) \nkernel\n, node \nkernel\n\n\n\n\nThe following \nsystem environment configurations\n are available within the \nruntime image metadata\n and therefore not be replicated in the ERC configuration file.\n\n\n\n\noperating system\n,  node \nos\n,\n\n\narchitecture\n, node \narchitecture\n\n\nruntime software version\n, node \nDockerVersion\n in output of \ndocker inspect\n and node \ndocker_version\n in image metadata JSON file (cf. \nsource code\n).\n\n\n\n\n\n\nAccessing system environment configurations from image metadata in a saved image tarball\n\n\nmanifest.json\n contains a list of the layers and the config as the name of the configuration file.\nThe image metadata is in the \n<image id>.json\n file in the root directory of the tarball.\nThe following commands show how to extract the image metadata file from the tarball and print the relevant properties to the console using the JSON cli tool \njq\n.\n\n$ tar -xf image.tar --wildcards --no-anchored '[!manifest]*.json'\n$ cat *.json | jq '.architecture, .os, .docker_version'\n\"amd64\"\n\"linux\"\n\"17.05.0-ce\"\n\n\n\n\nTogether the image metadata and ERC configuration file provide all properties of the underlying system environment.\nAn implementation SHOULD notify the user if the required system environment is incompatible with the implementation\u2019s capabilities.\n\n\n\n\nSystem environment incompatibilities\n\n\nA partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare.\nAn implementation could utilise \nsemantic versioning\n to improve its compatibility tests.\nAn incompatible operating system, e.g. \nlinux\n vs. \nwindows\n, and architecture, e.g. \namd64\n or \narm/v7\n, are likely to fail.\n\n\n\n\n\n\nExample of ERC configuration file with user-defined kernel and excerpt from runtime image metadata\n\n\nERC configuration file\n\n\nid: b9b0099e-9f8d\nspec_version: 1\nexecution:\n    kernel: `4.13.0-32-generic`\n\n\nImage metadata (excerpt)\n (results of an \ndocker image inspect\n call):\n\n[\n    {\n        \"Id\": \"sha256:87362162878143c5e10e94a6ec9b7e925b...\",\n        \"RepoTags\": [],\n        \"RepoDigests\": [],\n        \"Parent\": \"sha256:a280c143ff833d99274e96bbcfdc86...\",\n        \"Created\": \"2018-02-15T15:18:42.623467682Z\",\n        \"Container\": \"840b75b48121012a0847bbae148ed96df7...\",\n        \"ContainerConfig\": { ... },\n        \"DockerVersion\": \"17.05.0-ce\",\n        \"Author\": \"<http://o2r.info>\",\n        \"Config\": { ... },\n        \"Architecture\": \"amd64\",\n        \"Os\": \"linux\",\n        [...]\n    }\n]\n\n\nImage metadata (excerpt)\n (content of \n<image id>.json\n from \nimage.tar\n):\n\n{\n    \"architecture\": \"amd64\",\n    \"config\": { ...,\n        \"Labels\": {\n            \"maintainer\": \"o2r\"\n        }\n    },\n    \"container\": \"747198d654630530c2a6523abbc19e41d7fcf977833c6854a2a48fb11b8c607c\",\n    \"container_config\": { ... },\n    \"created\": \"2018-03-08T15:24:20.164740334Z\",\n    \"docker_version\": \"17.05.0-ce\",\n    \"history\": [ ... ],\n    \"os\": \"linux\",\n    \"rootfs\": {\n        \"type\": \"layers\",\n        \"diff_ids\": [\n            \"sha256:8568818b1f7f534832b393c531edfcb4a30e7eb40b573e68fdea90358987231f\",\n            \"sha256:fccd38ea8016190426aa7ef4baba29b0c92de1ee863c3460a34151695fbcba08\",\n            \"sha256:cf52051fff5bb6430c972ef822d435e9b5242117398b43c6d36f1ed71d978a94\",\n            \"sha256:5535e4fbfa3ed182d3cc87bfe643f87801c91be6c171535675effb4efc8c1e5a\",\n            \"sha256:9d55d57e41e02115f48e428a880d88d7bf0af993a232d0c967cc17f012e2e250\"\n        ]\n    }\n}\n\n\n\n\n\nExecution\n\u00b6\n\n\nThe configuration file MUST provide enough information to for implementations to create the \ncommands\n for execution of the runtime image and to provide access to the data and software in the ERC.\nImplementations MUST support \nDocker Engine API \nv1.35\n (or compatible).\n\n\nMaking data, code, and text available within container\n\u00b6\n\n\nThe runtime environment image contains all dependencies and libraries needed by the code in an ERC.\nEspecially for large datasets, it in unfeasible to replicate the complete dataset contained within the ERC in the image.\nFor archival, it can also be confusing to replicate code and text, albeit them potentially being relatively small in size, within the container.\n\n\nTherefore a host directory MUST be \nmounted\n (also \u201cbind-mounted\u201d) into the compendium container at runtime using a \ndata volume\n.\n\n\nThe Dockerfile MUST contain a \nVOLUME\n instruction to define the mount point of the ERC base directory within the container.\nThis mount point MUST be \n/erc\n and the bind MUST be configured as with \nread and write access\n.\nImplementations SHOULD make sure an execution does not interfere with original uploaded files, but a write access is required to store the created display file outside of the container.\n\n\nThe Dockerfile MUST contain a \nWORKDIR\n instruction with the value \n/erc\n.\n\n\nThe Dockerfile SHOULD NOT contain a \nCOPY\n or \nADD\n command to include data, code or text from the ERC into the image.\nThese commands MAY be used to copy code or libraries which must be available during the image build.\n\n\n\n\nExample Dockerfile\n\n\nIn this example we use a \nRocker\n base image to reproduce computations made in R.\n\n\nFROM rocker/r-ver:3.3.3\n\nRUN apt-get update -qq \\\n    && apt-get install -y --no-install-recommends \\\n    ## Packages required by R extension packages\n    # required by rmarkdown:\n    lmodern \\\n    pandoc \\\n    # for devtools (requires git2r, httr):\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    git \\\n    # for udunits:\n    libudunits2-0 \\\n    libudunits2-dev \\\n    # required when knitting the document\n    pandoc-citeproc \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# install R extension packages\nRUN install2.r -r \"http://cran.rstudio.com\" \\\n      rmarkdown \\\n      ggplot2 \\\n      devtools \\\n      && rm -rf /tmp/downloaded_packages/ /tmp/*.rd\n\n# Save installed packages to file\nRUN dpkg -l > /dpkg-list.txt\n\nLABEL maintainer=o2r \\\n  description=\"This is an ERC image.\" \\\n    info.o2r.bag.id=\"123456\"\n\nVOLUME [\"/erc\"]\nWORKDIR [\"/erc\"]\n\nENTRYPOINT [\"sh\", \"-c\"]\nCMD [\"R --vanilla -e \\\"rmarkdown::render(input = '/erc/myPaper.rmd', \\\n    output_dir = '/erc', output_format = rmarkdown::html_document())\\\"\"]\n\n\n\n\n\n\n\nMain and display file in the container\n\n\nThe fixed mount point have the advantage that users and tools can be sure the main and display files are usually available at \n/erc/main.Rmd\n and \n/erc/display.html\n respectively.\n\n\n\n\nDefault execution\n\u00b6\n\n\nIf no execution information is provided, then the implementation MUST assume an unconfigured Docker control flow for loading and executing the nested runtime environment is sufficient.\nUnconfigured means that NO configuration besides providing a mount of the compendium files (see previous section) MAY be applied.\n\n\nThe control statements for Docker executions comprise \nload\n, for importing an image from the archive, and \nrun\n for starting a container of the loaded image.\nBoth control statements MUST be configured by using nodes of the same name under the root-level node \nexecution\n in the ERC configuration file.\nBased on the configuration, an implementation can construct the respective runtime software\u2019s commands, i.e. \ndocker load\n and \ndocker run\n, using the correct image file name and further parameters (e.g. performance control options).\n\n\n\n\nConstructing the execution commands\n\n\nThe Docker CLI commands constructed based on configuration file for ERC with ID \nb9b0099e-9f8d\n could be as follows.\nIn this case the implementation uses \n-it\n to pass stdout streams to the user and adds an identifier for the container using \n--name\n.\n\ndocker load --input image.tar\ndocker run -it --name run_b9b0099e \\\n    --volume /storage/erc/abc123:/erc \\\n    erc:b9b0099e-9f8d\n\n\n\n\nThe output of the container during execution MAY be shown to the user to convey detailed information to users.\n\n\nAdjusted execution\n\u00b6\n\n\nTwo means MAY be used to adjust the execution of a compendium: \nenvironment variables\n and \nbind mounts\n.\n\n\nEnvironment variables\n can be \nset for containers\n at runtime.\nThey overwrite variables that are defined within the image and thus SHOULD be used sparsely, for example only when the same configuration can not be achieved within the main file, and only to \nincrease reproducibility\n.\n\n\nThe MUST NOT be used for \nmanipulating\n the compendium\u2019s workflow instead of using \nUI bindings\n.\n\n\n\n\nEnvironment variable use case: Time zone\n\n\nA possible use case for environment variables can be setting the time zone.\nWhen the display file contains text output of times and timestamps, running the analysis on a machine with a different time zone may wrongly cause errors during \nchecking\n.\nWhile a careful author can cover this within the main file via settings or controlling output, she may also be offered during a creation workflow to freeze the timezone.\nThe following command sets the system time zone to \nCET\n.\n\ndocker run -it --name run_b9b0099e \\\n    --volume /storage/erc/abc123:/erc --env TZ=CET \\\n    erc:b9b0099e-9f8d\n\n\n\n\nIn addition to the mandatory mount of all compendium files, \nbind mounts\n MAY be added to replace specific files for \nsubstitution\n.\n\n\nThe mounts MUST be configured in a list node \nbind_mounts\n under the root-level node \nexecution\n in the ERC configuration file.\nImplementations SHOULD apply them in the same order as given in the configuration file.\nEach mount MUST include the following nodes:\n\n\n\n\nsource\n: mount source file or directory.\n\n\ndestination\n: mount target path within the container; MUST be an absolute path.\n\n\n\n\nThe binds MUST be configured as read only.\n\n\nIf a list of mounts is configured, it MAY include the mandatory bind mount.\n\n\n\n\nExample: data file replacement with bind mounts\n\n\nThe following example includes an explicit definition of the mandatory mount to \n/erc\n and an overlay bind mount of a CSV file. \n\nid: b9b0099e-9f8d\nspec_version: 1\nexecution:\n    bind_mounts:\n        - source: '/storage/erc/abc123'\n          destination: /erc\n        - source: /storage/erc/other/input_data/fixed.csv\n          destination: /erc/data.csv\n\nIt can be translated by an implementation to the following bind string:\n\n/storage/compendium/other123/input_data/fixed.csv:/erc/data.csv:ro\n\n\n\n\n\n\nMore on mounts and binds\n\n\nSee Docker API specification section \nCreate a container\n > \nHostConfig\n > \nBinds\n/\nMounts\n.\n\n\n\n\nR workspaces\n\u00b6\n\n\nERC support the \nR\n software environment for statistical computing and graphics.\n\n\nStructure\n\u00b6\n\n\nThe structure (file names for data, directories, etc.) within the ERC are intentionally unspecified.\nHowever, the content\u2019s structure MAY follow conventions or be based on templates for organizing research artifacts.\n\n\nIf a convention is followed then it SHOULD be referenced in the ERC configuration file as a node \nconvention\n section.\nThe node\u2019s value can be any text string which uniquely identifies a convention, but a URI or URL to either a human-readable description or formal specification is RECOMMENDED.\n\n\nA non-exhaustive list of potential conventions and guidelines \nfor R\n is as follows:\n\n\n\n\nROpenSci rrrpkg\n\n\nJeff Hollister\u2019s manuscriptPackage\n\n\nCarl Boettiger\u2019s template\n\n\nFrancisco Rodriguez-Sanchez\u2019s template\n\n\nBen Marwick\u2019s template\n\n\nKarl Broman\u2019s comments on reproducibility\n\n\nR package: \u201cWriting R Extensions\u201d\n\n\n\n\n\n\nExample for using the ROPenSci \nrrrpkg\n convention\n\n\nThe convention is identified using the public link on GitHub.\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nconvention: https://github.com/ropensci/rrrpkg\n\n\n\n\nR Markdown main file\n\u00b6\n\n\nThe ERC\u2019s \nmain file\n for R-based analyses SHOULD be \nR Markdown\n.\n\n\nIf the main file is R Markdown, it SHOULD include basic metadata in its \nYAML front matter\n: author(s), title, date, et cetera.\n\n\nThe main document SHOULD NOT contain code that loads pre-computed results from files, but conduct all analyses, even costly ones, during document weaving.\n\n\nThe document MUST NOT use \ncache=TRUE\n on any of the code chunks (see \nknitr\n options\n.\nWhile the previously cached files (\n.rdb\n and \n.rdx\n) MAY be included, they SHOULD NOT be used during the rendering of the document.\n\n\n\n\nNote\n\n\nA popular alternative solution is \nSweave\n with the \n.Rnw\n extension, which is still widely used for vignettes. R Markdown was chosen of LaTex for its simplicity for users who are unfamiliar with LaTeX.\n\n\n\n\nFixing the environment in code\n\u00b6\n\n\nThe time zone MUST be fixed to \nUTC\n \nCoordinated Universal Time\n) to allow validation of output times (potentially broken by different output formats) by using the following code within the RMarkdown document, or other code to that effect.\n\n\nSys.setenv(\"TZ\" = \"UTC\")\n\n\n\nThe manifest file (i.e. \nDockerfile\n) MUST run a plain R session without loading \n.RData\n files or profiles at startup, i.e. use \nR --vanilla\n.\n\n\nInteractive ERC\n\u00b6\n\n\nEnabling interaction with the contents of an ERC is a crucial goal of this specification (see \nPreface\n).\nTherefore this section defines metadata to support two goals:\n\n\n\n\naide \ninspecting\n users to identify core functions and parameters of an analysis, and\n\n\nallow supporting software tools to create interactive renderings of ERC contents for \nmanipulation\n.\n\n\n\n\nThese goals are manifested in the \nUI bindings\n as part of the ERC configuration file under the root level property \nui_bindings\n.\n\n\nAn ERC MUST denote if UI bindings are present using the boolean property \ninteractive\n.\nIf the property is missing it defaults to \nfalse\n.\nAn implementation MAY use the indicator \ninteractive: true\n to provide other means of displaying the display file.\n\n\n\n\nExample for minimal interaction configuration\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nui_bindings:\n  interactive: true\n\n\n\n\n\nAn ERC MAY embed multiple concrete UI bindings.\nEach UI binding is represented by a YAML dictionary.\n\n\nIt MUST comprise a purpose and a widget using the fields \npurpose\n respectively \nwidget\n (both of type string).\nThe values of these fields SHOULD use a concept of an ontology to clearly identify their meaning.\n\n\nA \npurpose\n defines the user\u2019s intention, for example \nmanipulating\n a variable or \ninspecting\n dataset or code.\nA \nwidget\n realizes the purpose with a concrete interaction paradigm chosen by the author, for example an input slider, a form field, or a button.\n\n\nFor each widget, implementations MAY use the properties \ncode\n, \ndata\n, and \ntext\n to further describe how a specific UI binding acts upon the respective part of the ERC.\n\n\n\n\nExample of two UI bindings\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nui_bindings:\n  interactive: true\n  bindings:\n    - purpose: http://.../data-inspection\n      widget: http://.../tabular-browser\n      code: [...]\n      data: [...]\n      text: [...]\n    - purpose: http://.../parameter-manipulation\n      widget: http://.../dropdown\n\n\n\n\n\nPreservation of ERC\n\u00b6\n\n\nThis section places the ERC in the context of preservation workflows by defining structural information and other metadata that guarantee interpretability and enable the bundling of the complete ERC as a self-contained, archivable digital object.\n\n\nArchival bundle\n\u00b6\n\n\nFor the purpose of transferring and storing a complete ERC, it MUST be packaged using the \nBagIt File Packaging Format (V0.97)\n (BagIt) as the outer container.\nBagIt allows to store and transfer arbitrary content along with minimal metadata as well as checksum based payload validation.\n\n\nThe remainder of this section comprises\n\n\n\n\na description of the outer container,\n\n\na BagIt profile,\n\n\na package leaflet, and\n\n\nsecondary metadata files.\n\n\n\n\nBagIt outer container\n\u00b6\n\n\nThe ERC base directory MUST be the BagIt payload directory \ndata/\n.\nThe path to the ERC configuration file subsequently MUST be \n<path-to-bag>/data/erc.yml\n.\n\n\nThe bag metadata file \nbagit.txt\n MUST contain the case-sensitive label \nIs-Executable-Research-Compendium\n with the case-insensitive value \ntrue\n to mark the bag as the outer container of an ERC.\n\n\nImplementations SHOULD use this field to identify an ERC.\n\n\n\n\nExample \nbagit.txt\n\n\nPayload-Oxum: 2172457623.43\nBagging-Date: 2016-02-01\nBag-Size: 2 GB\nIs-Executable-Research-Compendium: true\n\n\n\n\n\n\n\nExample file tree for a bagged ERC\n\n\n\u251c\u2500\u2500 bag-info.txt\n\u251c\u2500\u2500 bagit.txt\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 2016-07-17-sf2.Rmd\n\u2502   \u251c\u2500\u2500 erc.yml\n\u2502   \u251c\u2500\u2500 metadata.json\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 image.tar\n\u251c\u2500\u2500 manifest-md5.txt\n\u2514\u2500\u2500 tagmanifest-md5.txt\n\n\n\n\n\nBagIt profile - DRAFT\n\u00b6\n\n\n\n\nNote\n\n\nThe elements of the o2r Bagit Profile is yet to be specified.\nThis section is under development.\nCurrent BagIt tools do not include an option to add a BagIt Profile automatically.\n\n\n\n\nA \nBagIt Profile\n as outlined below would make the requirements more explicit.\nThe BagIt Profiles Specification Draft allows users of BagIt bags to coordinate additional information, attached to bags.\n\n\n{\n  \"BagIt-Profile-Info\":{\n  \"BagIt-Profile-Identifier\":\"http://o2r.info/erc-bagit-v1.json\",\n  \"Source-Organization\":\"o2r.info\",\n  \"Contact-Name\":\"o2r Team\",\n  \"Contact-Email\":\"o2r@uni-muenster.de\",\n  \"External-Description\":\"BagIt profile for packaging\n        executable research compendia.\",\n  \"Version\":\"1\"\n  },\n  \"Bag-Info\":{\n    \"Contact-Name\":{\n       \"required\":true\n    },\n    \"Contact-Email\":{\n       \"required\":true\n    },\n    \"External-Identifier\":{\n       \"required\":true\n    },\n    \"Bag-Size\":{\n       \"required\":true\n    },\n    \"Payload-Oxum\":{\n       \"required\":true\n    }\n  },\n  \"Manifests-Required\":[\n    \"md5\"\n  ],\n  \"Allow-Fetch.txt\":false,\n  \"Serialization\":\"optional\",\n  \"Accept-Serialization\":[\n     \"application/zip\"\n  ],\n  \"Tag-Manifests-Required\":[\n    \"md5\"\n  ],\n  \"Tag-Files-Required\":[\n     \".erc/metadata.json\",\n     \"erc.yml\"\n  ],\n  \"Accept-BagIt-Version\":[\n     \"0.96\"\n  ]\n}\n\n\n\nPackage leaflet\n\u00b6\n\n\nEach ERC MUST contain a package leaflet, describing the schemas and standards used. Available schema files are supposed to be included with the ERC, if available (licenses for these schemas may apply).\n\n\n\n\nExample package leaflet\n\n\n{\n    \"standards_used\": [\n        {\n            \"o2r\": {\n                \"map_description\": \"maps raw extracted metadata to\n                    o2r schema compliant metadata\",\n                \"mode\": \"json\",\n                \"name\": \"o2r\",\n                \"outputfile\": \"metadata_o2r.json\",\n                \"root\": \"\"\n            }\n        },\n        {\n            \"zenodo_sandbox\": {\n                \"map_description\": \"maps o2r schema compliant MD to\n                    Zenodo Sandbox for deposition creation\",\n                \"mode\": \"json\",\n                \"name\": \"zenodo_sandbox\",\n                \"outputfile\": \"metadata_zenodo_sandbox.json\",\n                \"root\": \"metadata\"\n            }\n        }\n    ]\n}\n\n\n\n\n\nElements used for each schema standard used are contributed via the MD mapping files in the o2r meta tool suite.\n\n\nSecondary metadata files\n\u00b6\n\n\nThe ERC as an object can be used in a broad range of cases. For example, it can be an item under review during a journal publication, it can be the actual publication at a workshop or conference or it can be a preserved item in a digital archive. All of these have their own standards and requirements to apply, when it comes to metadata.\n\n\nThese metadata requirements \nare not\n part of this specification, but the following conventions are made to simplify and coordinate the variety.\n\n\nMetadata specific to a particular domain or use case MUST replicate the information required for the specific case in an independent file.\nDomain metadata SHOULD follow domain conventions and standards regarding format and encoding of metadata.\nDuplicate information is accepted, because it lowers the entry barrier for domain experts and systems, who can simply pick up a metadata copy in a format known to them.\n\n\nMetadata documents of specific use cases MUST be stored in a directory \n.erc\n, which is a child-directory of the ERC base directory.\n\n\nMetadata documents SHOULD be named according to the used standard/model, format/encoding, and version, e.g. \ndatacite40.xml\n or \nzenodo_sandbox10.json\n, and SHOULD use a suitable mime type.\n\n\nRequirements of secondary metadata\n\u00b6\n\n\nIn order to comply to their governing schemas, secondary metadata must include the mandatory information as set by 3rd party services. While the documentation of this quality is a perpetual task, we have gathered the information most relevant our selection of connected services.\n\n\nZenodo\n\n\n\n\nAccepts metadata as \nJSON\n.\n\n\nMandatory elements:\n\n\nUpload Type (e.g. Publication)\n\n\nPublication Type\n\n\nTitle\n\n\nCreators\n\n\nDescription\n\n\nPublication Date\n\n\nAccess Right\n\n\nLicense\n\n\n\n\n\n\n\n\nDataCite (4.0)\n\n\n\n\nAccepts metadata as \nXML\n.\n\n\nMandatory elements:\n\n\nIdentifier\n\n\nCreator\n\n\nTitle\n\n\nPublisher\n\n\nPublication Year\n\n\nResource Type\n\n\n\n\n\n\n\n\nDevelopment bundle\n\u00b6\n\n\nWhile complete ERCs are focus of this specification, for collaboration and offline \ninspection\n it is useful to provide access to parts of the ERC.\nTo support such use cases, a \ndevelopment bundle\n MAY be provided by implementations.\nThis bundle most importantly would not include the \nruntime image\n, which is potentially a large file.\n\n\nThe \ndevelopment bundle\n SHOULD always include the \nmain file\n and (e.g. by choice of the user, or by an implementing platform) MAY include other relevant files for reproduction or editing purposes outside of the runtime environment, such as input data or the \nruntime manifest\n for manual environment recreation.\n\n\nContent metadata\n\u00b6\n\n\nThe current JSON dummy file to visualises the properties. These elements SHOULD be filled out as good as possible in the user interface.\n\n\n{\n    \"access_right\": \"open\",\n    \"author\": [{\n        \"name\": null,\n        \"affiliation\": [],\n        \"orcid\": null\n    }],\n    \"codefiles\": [],\n    \"community\": \"o2r\",\n    \"depends\": [{\n        \"identifier\": null,\n        \"version\": null,\n        \"packageSystem\": null\n    }],\n    \"description\": null,\n    \"ercIdentifier\": null,\n    \"file\": {\n        \"filename\": null,\n        \"filepath\": null,\n        \"mimetype\": null\n    },\n    \"generatedBy\": null,\n    \"identifier\": {\n        \"doi\": null,\n        \"doiurl\": null,\n        \"reserveddoi\": null\n    },\n  \"inputfiles\": [],\n    \"keywords\": [],\n    \"license\": {\"text\": None,\n            \"data\": None,\n            \"code\": None,\n            \"uibindings\": None,\n            \"md\": None\n            },\n    \"paperLanguage\": [],\n    \"paperSource\": null,\n    \"publicationDate\": null,\n    \"recordDateCreated\": null,\n    \"softwarePaperCitation\": null,\n    \"spatial\": {\n        \"files\": [],\n        \"union\": []\n    },\n    \"temporal\": {\n        \"begin\": null,\n        \"end\": null\n    },\n    \"title\": null,\n    \"upload_type\": \"publication\",\n    \"viewfiles\": []\n}\n\n\n\nThe path to the o2r metadata file MUST be\n\n\n<path-to-bag>/data/metadata_raw.json\n\n\nand the refined version \nmetadata_o2r.json\n.\n\n\nDescription of o2r metadata properties\n\u00b6\n\n\n\n\naccess_right\n \nString\n.\n\n\ncreators\n \nArray of objects\n.\n\n\ncreators.name\n \nString\n.\n\n\ncreators.orcid\n \nString\n.\n\n\ncreators.affiliation\n \nString\n.\n\n\ncodefiles\n \nArray of strings\n List of all files of the recursively parsed workspace that have an extension belonging to a (\u201cR\u201d) codefile.\n\n\ncommunities\n \nArray of objects\n prepared zenodo MD element\n\n\ncommunities[0].identifier\n \nString\n. Indicating the collection as required in zenodo MD, default \u201co2r\u201d.\n\n\ndepends\n \nArray of objects\n.\n\n\ndepends.operatingSystem\n \nString\n.\n\n\ndepends.identifier\n \nString\n.\n\n\ndepends.packageSystem\n \nString\n. URL\n\n\ndepends.version\n \nString\n.\n\n\ndescription\n \nString\n. A text representation conveying the purpose and scope of the asset (the abstract).\n\n\ndisplayfile\n \nString\n. The suggested file for viewing the text of the workspace, i.e. a rendering of the suggested mainfile.\n\n\ndisplayfile_candidates\n \nArray of strings\n. An unsorted list of candidates for displayfiles.\n\n\nercIdentifier\n \nString\n. A universally unique character string associated with the asset as executable research compendium, provided by the o2r service.\n\n\nidentifier\n \nObject\n.\n\n\ninputfiles\n \nArray of strings\n. A compiled list of files from the extracted workspace that is called or used in the extracted code of the workspace.\n\n\ninteraction\n TBD\n\n\nkeywords\n \nArray of strings\n. Tags associated with the asset.\n\n\nlicense\nObject\n.  License information for the entire ERC.\n\n\nlicense.code\n \nString\n. License information for the code included.\n\n\nlicense.data\nString\n. License information for the data included.\n\n\nlicense.md\n \nString\n. License information for the metadata included. Should be cc0 to include in catalogues.\n\n\nlicense.text\nString\n. License information for the text included.\n\n\nlicense.uibindings\n \nString\n. License information for the UI-bindings included.\n\n\nmainfile\n \nString\n. The suggested main file of workspace\n\n\nmainfile_candidates\n \nArray\n. Unsorted list of mainfile candidates of the workspace.\n\n\npaperLanguage\n \nArray of strings\n. List of guessed languages for the workspace.\n\n\npublication_date\n \nString\n. The publication date of the paper publication as ISO8601 string.\n\n\npublication_type\n \nString\n.\n\n\nrelated_identifier\n \nString\n.\n\n\nspatial\n \nObject\n. Spatial information of the workspace.\n\n\nspatial.files\n \nArray of objects\n.\n\n\nspatial.union\n \nArray of objects\n.\n\n\ntemporal\n \nObject\n. Aggregated information about the relevant time period of the underlying data sets.\n\n\ntemporal.begin\n\n\ntemporal.end\n\n\ntitle\n The distinguishing name of the paper publication.\n\n\nupload_type\n \nString.\n Zenodo preset. Defaults to \u201cpublication\u201d.\n\n\n\n\nERC checking\n\u00b6\n\n\nProcedure\n\u00b6\n\n\nA core feature ERCs are intended to support is comparing the output of an ERC executions with the original outputs.\nTherefore \nchecking\n an ERC always comprises two steps: the execution and the comparison.\n\n\nThe files included in the comparison are the \ncomparison set\n.\nAn implementation MUST communicate the comparison set to the user as part of a check.\n\n\nPrevious to the check, an implementation SHOULD conduct a basic validation of the outer container\u2019s integrity, i.e. check the file hashes.\nThe output of the image execution can be shown to the user to convey detailed information on progress or errors.\n\n\nComparison set file\n\u00b6\n\n\nThe ERC MAY contain a file named \n.ercignore\n in the base directory to define the comparison set.\n\n\nIts purpose is to provide a way to efficiently exclude files and directories from \nchecking\n.\nIf this file is present, any files and directories within the outer container which match the patterns within the file \n.ercignore\n will be excluded from the checking process.\nThe check MUST NOT fail when files listed in \n.ercignore\n are failing comparison.\n\n\nThe file MUST be UTF-8 (without BOM) encoded.\nThe newline-separated patterns in the file MUST be \nUnix shell globs\n.\nFor the purposes of matching, the root of the context is the ERC\u2019s base directory.\n\n\nLines starting with \n#\n are treated as comments and MUST be ignored by implementations.\n\n\n\n\nExample \n.ercignore\n file\n\n\n# comment\n.erc\n*/temp*\ndata-old/*\n\n\n\n\n\n\n\nNote\n\n\nIf using \nmd5\n file hashes for comparison, the set could include plain text files, for example the \ntext/*\n \nmedia types\n (see \nIANA\u2019s full list of media types\n.\nOf course the comparison set should include files which contain results of an analysis.\n\n\n\n\nComparing plain text documents\n\u00b6\n\n\n\u2026\n\n\nComparing graphics and binary output\n\u00b6\n\n\nThis section outlines possibilities beyond simple comparison and incorporates \u201charder\u201d to compare files and what to do with them, e.g. plots/figures, PDF files, \u2026\n\n\nComprehensive example of erc.yml\n\u00b6\n\n\nThe following example shows all possible fields of the ERC specification with example values.\n\n\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nmain: paper.rmd\ndisplay: paper.html\nexecution:\n  bind_mounts: ...\nlicenses:\n  code: MIT\n  data: ODbL-1.0\n  text: \"data_licenses_info.pdf\"\n  ui_bindings: CC0-1.0\n  metadata: CC0-1.0\nconvention: https://github.com/ropensci/rrrpkg\nui_bindings:\n  interactive: true\n  bindings:\n    - purpose: http://.../data-inspection\n      widget: http://.../tabular-browser\n      code: [...]\n      data: [...]\n      text: [...]\n    - purpose: http://.../parameter-manipulation\n      widget: http://.../dropdown",
            "title": "ERC specification"
        },
        {
            "location": "/spec/#erc-specification",
            "text": "An Executable Research Compendium (ERC) is a packaging convention for computational research.\nIt provides a well-defined structure for data, code, text, documentation, and user interface controls for a piece of research and is suitable for long-term archival. As such it can also be perceived as a digital object or asset.   Note  This is a draft specification. If you have comments or suggestions please file them in the  issue tracker . If you have explicit changes please fork the  git repo  and submit a pull request.",
            "title": "ERC specification"
        },
        {
            "location": "/spec/#preface",
            "text": "",
            "title": "Preface"
        },
        {
            "location": "/spec/#version",
            "text": "Specification version:  1   Warning  This version is  under development !",
            "title": "Version"
        },
        {
            "location": "/spec/#notational-conventions",
            "text": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d are to be interpreted as described in  RFC 2119 .  The key words \u201cunspecified\u201d, \u201cundefined\u201d, and \u201cimplementation-defined\u201d are to be interpreted as described in the  rationale for the C99 standard .",
            "title": "Notational conventions"
        },
        {
            "location": "/spec/#purpose-target-audience-and-context",
            "text": "This specification defines a structure to transport and execute a computational scientific analysis (cf.  computational science ).\nIt carries technical and conceptual details on how to implement tools to enhance reproducibility and is most suitable  for developers . Authors  may feel more comfortable with the  user guides .  These analyses typically comprise a digital workspace on a researcher\u2019s computer, which contains  data  ( born digital , simulated, or other),  code , third party  software  or libraries, and  outputs  of research such as digital plots or data.\nCode and libraries are required in executable form to re-do a specific analysis or workflow.\nResearch is only put into a context by a  text , e.g. a research paper, which is published in  scholarly communication .\nThe text comes in two forms: one that is machine readable, and another one that is suitable for being viewed by humans.\nThe latter is derived, or \u201crendered\u201d, from the former.\nThe viewing experience can be static, textual, visual, or interactive.  Putting all of these elements in a self-contained bundle allows examining, reproducing, transferring, archiving, and formally validating computational research results in a time frame for peer review and collaboration.\nThe ERC specification defines metadata and file structures to support these actions.",
            "title": "Purpose, target audience, and context"
        },
        {
            "location": "/spec/#major-constituents",
            "text": "Three major constituents group possible user interactions with ERC.   Create  Creation  is transforming a workspace with data, code and text into an ERC.  Examine  Examination  is evaluating ERC at different levels, from inspecting contents to creating derived analyses.  Discover  Discovery  is searching for content powered by ERC properties, such as text, content metadata, code metadata et cetera.",
            "title": "Major constituents"
        },
        {
            "location": "/spec/#design-principles",
            "text": "Simplicity  This specification should not re-do something which already exists (if it is an open specification or tool).\n  The risk of scattering information is mitigated by clear documentation. \n  It must be possible to create a valid and working ERC  manually , while supporting tools should be able to cover typical use cases with minimal required input by a creating user.  Nested containers  We acknowledge well defined standards for packaging a set of files, and different approaches to create an executable code package.\n  Therefore an ERC comprises  one or more containers but is itself subject to being put into a container .\n  We distinguish these containers into the inner or \u201cruntime\u201d container and the outer container, which is used for transfer of complete ERC and not content-aware validation.  Transparency, Stability, and Openness  Plain text files usable by both humans and computers are the backbone to make sure ERCs are acceptable by users from all scientific domains, are understandable today and tomorrow, and are easy to extend.\n  The ERC contains everything needed to execute a workflow.",
            "title": "Design principles"
        },
        {
            "location": "/spec/#how-to-use-an-erc",
            "text": "The steps to (re-)run the analysis contained in an ERC as part of an  examination  are as follows:   (if compressed first extract then) unpack the ERC\u2019s outer container  execute the runtime container  compare the output files contained in the outer container with the output files just created by the runtime container   This way an ERC allows computational reproducibility based on the original code and data.",
            "title": "How to use an ERC"
        },
        {
            "location": "/spec/#three-questions",
            "text": "[Section inspired by  REANA\u2019s \u201cFour Questions\u201d ]  The ERC helps to make research papers more transparent an reusable by giving minimal structure for contents and context.\nThey help to answer the \u201cThree Questions\u201d both for users, but more importantly for tools and services built around them.   What is your result?  file I should look at to see the description and visualisations  the \u201cdisplay file\u201d shown by applications based on ERC    What is your workflow?  file I should look at as a reader when I want to understand your code/analysis/workflow, the steps you took  the \u201cmain file\u201d used by applications based on ERC for creating ERCs and executing them, which means running the analysis and creating the result    What is your environment?  operating system you used  software you used (libraries, your own scripts, \u2026)  can be used by tools to recreate the same environment",
            "title": "Three questions"
        },
        {
            "location": "/spec/#erc-structure",
            "text": "",
            "title": "ERC structure"
        },
        {
            "location": "/spec/#base-directory",
            "text": "An ERC MUST has a  base directory . All paths within this document are relative to this base directory.  The base directory MUST contain an  ERC configuration file .  Besides the files mentioned in this specification, the base directory MAY contain any other files and directories.",
            "title": "Base directory"
        },
        {
            "location": "/spec/#main-display-file",
            "text": "An ERC MUST have a  main file, i.e. the file which contains the text and instructions being the basis for the scientific publication describing the packaged analysis.\nAn ERC MUST have a _display file , i.e. the file which is shown to a user first when she opens an ERC in a supporting platform or tool.  Main file  and  display file  MUST NOT be the same file.  The  main file  MUST be  executable  in the sense that a software reads it as the input of a process to create the  display file .\nThe  main file \u2018s name SHOULD be  main  with an appropriate file extension and  media type .   Note  The  main file  thus follows the  literate programming paradigm .    Example  If the main file is an R Markdown document, then the file extension should be  .Rmd  and the media type  text/markdown .\nA file  main.Rmd  will consequently be automatically identified by an implementation as the ERC\u2019s  main file .   The display file\u2019s name SHOULD be  display  with an appropriate file extension and media type.   Example  If the display file is an Hypertext Markup Language (HTML) document, then the file extension should be  .htm  or  .html  and the media type  text/html .\nA file  display.html  will consequently be automatically identified by an implementation as the ERC\u2019s  display file .   The ERC MAY use an interactive document with interactive figures and control elements for the packaged computations as the  display file .\nThe  interactive display file  MUST have  HTML  format and SHOULD be valid  HTML5 .   Example  Typical examples for the two core documents are R Markdown with HTML output (i.e.  main.Rmd  and  display.html ), or an  R  script creating a PNG file (i.e.  main.R  and  display.png ).",
            "title": "Main &amp; display file"
        },
        {
            "location": "/spec/#nested-runtime",
            "text": "The embedding of a representation of the original runtime environment, in which the analysis was conducted, is crucial for supporting reproducible computations.\nEvery ERC MUST include two such such representations:   an  executable runtime image  of the original analysis environment for re-running the packaged analysis, and   a  runtime manifest  documenting the image\u2019s contents as a complete, self-consistent recipe of the runtime image\u2019s contents which is a machine-readable format that allows a respective tool to create the runtime image.   The image MUST be stored as a file, e.g. a \u201cbinary\u201d or \u201carchive\u201d, in the ERC base directory.  The manifest MUST be stored as a text file in the ERC base directory.  System environment  The nested runtime encapsulates software, files, and configurations up to a specific level of abstraction.\nIt may not include a complete operating system, for example for better performance or security reasons.\nWhile this information is included in the nested runtime, it MUST be accessible without executing the runtime.\nHard to obtain information SHOULD be replicated in the configuration file.  If the nested runtime does not include the operating system, then the configuration file MUST include the following data about the environment used to create the ERC:   architecture  operating system  kernel  (if applicable)  runtime software version   An implementation SHOULD notify the user if the provided system environment is incompatible with the implementations capabilities.   Tip  A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare.\nAn implementation may utilise  semantic versioning  to improve its compatibility tests.\nAn incompatible operating system, e.g.  linux  vs.  windows , and architecture, e.g.  amd64  or  arm/v7 , are likely to fail.",
            "title": "Nested runtime"
        },
        {
            "location": "/spec/#erc-configuration-file",
            "text": "The ERC configuration file is the  reproducibility manifest  for an ERC. It defines the main entry points for actions performed on an ERC and core metadata elements.",
            "title": "ERC configuration file"
        },
        {
            "location": "/spec/#name-format-and-encoding",
            "text": "The filename MUST be  erc.yml  and it MUST be located in the base directory.\nThe contents MUST be valid  YAML 1.2 .\nThe file MUST be encoded in  UTF-8  and MUST NOT contain a byte-order mark (BOM).",
            "title": "Name, format, and encoding"
        },
        {
            "location": "/spec/#basic-fields",
            "text": "The first document content of this file MUST contain the following string nodes at the root level.   spec_version : a text string noting the version of the used ERC specification. The appropriate version for an ERC conforming to this version of the specification is  1 .  id : globally unique identifier for a specific ERC.  id  MUST not be empty and MUST only contain lowercase letters, uppercase letters, digits and single separators. Valid separators are period, underscore, or dash. A name component MUST NOT start or end with a separator. An implementation MAY introduce further restrictions on minimum and maximum length of identifiers.    Note  While URIs (see  rfc3986 ) are very common identifiers, not all systems support them as identifiers.\nFor example they cannot be used for Docker image names.\nA  UUID  is a valid  id .\nA regular expression to validate identifiers is  /^[^-_.][a-zA-Z0-9._-]+[^-_.]$/ .   The main and display file MAY be defined in root-level nodes named  main  and  display  respectively.\nIf they are not defined and multiple documents use the name  main.[ext]  or  display.[ext] , an implementation SHOULD use the first file in  alphabetical order .   Example of ERC configuration file with user-defined main and display files  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nmain: workflow.Rmd\ndisplay: paper.html   Additionally, related resources such as a related publication can be stated with the  relatedIdentifier  element field.\nA related identifier SHOULD be a globally unique persistent identifier and SHOULD be a URI.",
            "title": "Basic fields"
        },
        {
            "location": "/spec/#author-and-license-metadata",
            "text": "The main document MUST include information about the authors.\nIt SHOULD contain this information in a structured way so it can be parsed by tools supporting ERCs.  The file  erc.yml  MUST contain a first level node  licenses  with licensing information for contained artefacts.\nEach of these artefacts, e.g. code or data, have distinct requirements so it must be possible to apply different licenses.  The node  licenses  MUST have five child nodes:  text ,  data ,  code ,  ui_bindings , and  metadata .   Note  There is currently no mechanism to define the licenses of all the used libraries and software in a structured format.\nManual creation would be tedious.\nTools for automatic creation of ERC may add such detailed licensing information and define additional metadata elements.   The content of each of these child nodes MUST be a string with one of the following contents:   license identifier  as defined by the  Open Definition Licenses Service  name of file  with either documentation on licensing or a full license text    Example for common licenses  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n    code: Apache-2.0\n    data: ODbL-1.0\n    text: CC0-1.0\n    ui_bindings: CC0-1.0\n    metadata: CC0-1.0    Example for non-standard licenses  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n    code: Apache-2.0\n    data: data-licenses.txt\n    text: \"Creative Commons Attribution 2.0 Generic (CC BY 2.0)\"\n    ui_bindings: CC0-1.0\n    metadata: \"see metadata license headers\"",
            "title": "Author and license metadata"
        },
        {
            "location": "/spec/#runtime-manifest-and-image",
            "text": "The ERC uses  Docker  to define, build, and store the nested runtime environment.",
            "title": "Runtime manifest and image"
        },
        {
            "location": "/spec/#runtime-image",
            "text": "The  runtime environment or image  MUST be represented by a  Docker image  v1.2.0 .   Note  A concrete implementation of ERC may choose to rely on constructing the runtime environment from the manifest when needed, e.g. for export to a repository, while the ERC is constructed.   The base directory MUST contain a  tarball , i.e. an archive file, of a Docker image as created be the command  docker save , see  Docker CLI save command documentation , as defined in version  1.12.x .  The image MUST have a tag  erc:<erc identifier> , for example  erc:b9b0099e-9f8d-4a33-8acf-cb0c062efaec .  The image file MAY be compressed.  The image archive file name MUST be  image  with an appropriate file extension, such as  .tar ,  .tar.gz  (if a  gzip compression is used for the archive ) or  .bin , and have an appropriate mime type, e.g.  application/vnd.oci.image.layer.tar+gzip .   Note  Before exporting the Docker image, it should be  build  from the runtime manifest, including the tag which can be used to identify the image, for example: docker build --tag erc:b9b0099e-9f8d .\ndocker images erc:b9b0099e-9f8d\ndocker save erc:b9b0099e-9f8d > image.tar\n# save with compression:\ndocker save erc:b9b0099e-9f8d | gzip -c > image.tar.gz \nDo  not  use  docker export , because it is used to create a snapshot of a container, which must not match the Dockerfile anymore as it may have been  manipulated  during a run.",
            "title": "Runtime image"
        },
        {
            "location": "/spec/#runtime-manifest",
            "text": "The  runtime manifest  MUST be represented by a valid  Dockerfile , see  Docker builder reference , as defined in version  1.12.x .  The file MUST be named  Dockerfile .  The Dockerfile MUST contain the build instructions for the runtime environment and MUST have been used to create the image saved to the  runtime image  using  docker build , see  Docker CLI build command documentation , as defined in version  1.12.x .\nThe build SHOULD be done with the option  --no-cache=true .  The Dockerfile MUST NOT use the  latest  tag in the instruction  FROM .   Note  The \u201clatest\u201d tag is  merely a convention  to denote the latest available image, so any tag can have undesired results.\nNevertheless, using an image tagged \u201clatest\u201d makes it much more likely to change over time.\nAlthough there is no guarantee that images tagged differently, e.g. \u201cv1.2.3\u201d might not change as well, using such tags shall be enforced here.   The Dockerfile SHOULD contain the  label  maintainer  to provide authorship information.  The Dockerfile MUST have an active instruction  CMD , or a combination of the instructions  ENTRYPOINT  and  CMD , which executes the packaged analysis.  The Dockerfile SHOULD NOT contain  EXPOSE  instructions.",
            "title": "Runtime manifest"
        },
        {
            "location": "/spec/#system-environment",
            "text": "The following  system environment configurations  MUST be provided as nodes under the root-level node  execution :   (if applicable)  kernel , node  kernel   The following  system environment configurations  are available within the  runtime image metadata  and therefore not be replicated in the ERC configuration file.   operating system ,  node  os ,  architecture , node  architecture  runtime software version , node  DockerVersion  in output of  docker inspect  and node  docker_version  in image metadata JSON file (cf.  source code ).    Accessing system environment configurations from image metadata in a saved image tarball  manifest.json  contains a list of the layers and the config as the name of the configuration file.\nThe image metadata is in the  <image id>.json  file in the root directory of the tarball.\nThe following commands show how to extract the image metadata file from the tarball and print the relevant properties to the console using the JSON cli tool  jq . $ tar -xf image.tar --wildcards --no-anchored '[!manifest]*.json'\n$ cat *.json | jq '.architecture, .os, .docker_version'\n\"amd64\"\n\"linux\"\n\"17.05.0-ce\"   Together the image metadata and ERC configuration file provide all properties of the underlying system environment.\nAn implementation SHOULD notify the user if the required system environment is incompatible with the implementation\u2019s capabilities.   System environment incompatibilities  A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare.\nAn implementation could utilise  semantic versioning  to improve its compatibility tests.\nAn incompatible operating system, e.g.  linux  vs.  windows , and architecture, e.g.  amd64  or  arm/v7 , are likely to fail.    Example of ERC configuration file with user-defined kernel and excerpt from runtime image metadata  ERC configuration file  id: b9b0099e-9f8d\nspec_version: 1\nexecution:\n    kernel: `4.13.0-32-generic`  Image metadata (excerpt)  (results of an  docker image inspect  call): [\n    {\n        \"Id\": \"sha256:87362162878143c5e10e94a6ec9b7e925b...\",\n        \"RepoTags\": [],\n        \"RepoDigests\": [],\n        \"Parent\": \"sha256:a280c143ff833d99274e96bbcfdc86...\",\n        \"Created\": \"2018-02-15T15:18:42.623467682Z\",\n        \"Container\": \"840b75b48121012a0847bbae148ed96df7...\",\n        \"ContainerConfig\": { ... },\n        \"DockerVersion\": \"17.05.0-ce\",\n        \"Author\": \"<http://o2r.info>\",\n        \"Config\": { ... },\n        \"Architecture\": \"amd64\",\n        \"Os\": \"linux\",\n        [...]\n    }\n]  Image metadata (excerpt)  (content of  <image id>.json  from  image.tar ): {\n    \"architecture\": \"amd64\",\n    \"config\": { ...,\n        \"Labels\": {\n            \"maintainer\": \"o2r\"\n        }\n    },\n    \"container\": \"747198d654630530c2a6523abbc19e41d7fcf977833c6854a2a48fb11b8c607c\",\n    \"container_config\": { ... },\n    \"created\": \"2018-03-08T15:24:20.164740334Z\",\n    \"docker_version\": \"17.05.0-ce\",\n    \"history\": [ ... ],\n    \"os\": \"linux\",\n    \"rootfs\": {\n        \"type\": \"layers\",\n        \"diff_ids\": [\n            \"sha256:8568818b1f7f534832b393c531edfcb4a30e7eb40b573e68fdea90358987231f\",\n            \"sha256:fccd38ea8016190426aa7ef4baba29b0c92de1ee863c3460a34151695fbcba08\",\n            \"sha256:cf52051fff5bb6430c972ef822d435e9b5242117398b43c6d36f1ed71d978a94\",\n            \"sha256:5535e4fbfa3ed182d3cc87bfe643f87801c91be6c171535675effb4efc8c1e5a\",\n            \"sha256:9d55d57e41e02115f48e428a880d88d7bf0af993a232d0c967cc17f012e2e250\"\n        ]\n    }\n}",
            "title": "System environment"
        },
        {
            "location": "/spec/#execution",
            "text": "The configuration file MUST provide enough information to for implementations to create the  commands  for execution of the runtime image and to provide access to the data and software in the ERC.\nImplementations MUST support  Docker Engine API  v1.35  (or compatible).",
            "title": "Execution"
        },
        {
            "location": "/spec/#making-data-code-and-text-available-within-container",
            "text": "The runtime environment image contains all dependencies and libraries needed by the code in an ERC.\nEspecially for large datasets, it in unfeasible to replicate the complete dataset contained within the ERC in the image.\nFor archival, it can also be confusing to replicate code and text, albeit them potentially being relatively small in size, within the container.  Therefore a host directory MUST be  mounted  (also \u201cbind-mounted\u201d) into the compendium container at runtime using a  data volume .  The Dockerfile MUST contain a  VOLUME  instruction to define the mount point of the ERC base directory within the container.\nThis mount point MUST be  /erc  and the bind MUST be configured as with  read and write access .\nImplementations SHOULD make sure an execution does not interfere with original uploaded files, but a write access is required to store the created display file outside of the container.  The Dockerfile MUST contain a  WORKDIR  instruction with the value  /erc .  The Dockerfile SHOULD NOT contain a  COPY  or  ADD  command to include data, code or text from the ERC into the image.\nThese commands MAY be used to copy code or libraries which must be available during the image build.   Example Dockerfile  In this example we use a  Rocker  base image to reproduce computations made in R.  FROM rocker/r-ver:3.3.3\n\nRUN apt-get update -qq \\\n    && apt-get install -y --no-install-recommends \\\n    ## Packages required by R extension packages\n    # required by rmarkdown:\n    lmodern \\\n    pandoc \\\n    # for devtools (requires git2r, httr):\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    git \\\n    # for udunits:\n    libudunits2-0 \\\n    libudunits2-dev \\\n    # required when knitting the document\n    pandoc-citeproc \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# install R extension packages\nRUN install2.r -r \"http://cran.rstudio.com\" \\\n      rmarkdown \\\n      ggplot2 \\\n      devtools \\\n      && rm -rf /tmp/downloaded_packages/ /tmp/*.rd\n\n# Save installed packages to file\nRUN dpkg -l > /dpkg-list.txt\n\nLABEL maintainer=o2r \\\n  description=\"This is an ERC image.\" \\\n    info.o2r.bag.id=\"123456\"\n\nVOLUME [\"/erc\"]\nWORKDIR [\"/erc\"]\n\nENTRYPOINT [\"sh\", \"-c\"]\nCMD [\"R --vanilla -e \\\"rmarkdown::render(input = '/erc/myPaper.rmd', \\\n    output_dir = '/erc', output_format = rmarkdown::html_document())\\\"\"]    Main and display file in the container  The fixed mount point have the advantage that users and tools can be sure the main and display files are usually available at  /erc/main.Rmd  and  /erc/display.html  respectively.",
            "title": "Making data, code, and text available within container"
        },
        {
            "location": "/spec/#default-execution",
            "text": "If no execution information is provided, then the implementation MUST assume an unconfigured Docker control flow for loading and executing the nested runtime environment is sufficient.\nUnconfigured means that NO configuration besides providing a mount of the compendium files (see previous section) MAY be applied.  The control statements for Docker executions comprise  load , for importing an image from the archive, and  run  for starting a container of the loaded image.\nBoth control statements MUST be configured by using nodes of the same name under the root-level node  execution  in the ERC configuration file.\nBased on the configuration, an implementation can construct the respective runtime software\u2019s commands, i.e.  docker load  and  docker run , using the correct image file name and further parameters (e.g. performance control options).   Constructing the execution commands  The Docker CLI commands constructed based on configuration file for ERC with ID  b9b0099e-9f8d  could be as follows.\nIn this case the implementation uses  -it  to pass stdout streams to the user and adds an identifier for the container using  --name . docker load --input image.tar\ndocker run -it --name run_b9b0099e \\\n    --volume /storage/erc/abc123:/erc \\\n    erc:b9b0099e-9f8d   The output of the container during execution MAY be shown to the user to convey detailed information to users.",
            "title": "Default execution"
        },
        {
            "location": "/spec/#adjusted-execution",
            "text": "Two means MAY be used to adjust the execution of a compendium:  environment variables  and  bind mounts .  Environment variables  can be  set for containers  at runtime.\nThey overwrite variables that are defined within the image and thus SHOULD be used sparsely, for example only when the same configuration can not be achieved within the main file, and only to  increase reproducibility .  The MUST NOT be used for  manipulating  the compendium\u2019s workflow instead of using  UI bindings .   Environment variable use case: Time zone  A possible use case for environment variables can be setting the time zone.\nWhen the display file contains text output of times and timestamps, running the analysis on a machine with a different time zone may wrongly cause errors during  checking .\nWhile a careful author can cover this within the main file via settings or controlling output, she may also be offered during a creation workflow to freeze the timezone.\nThe following command sets the system time zone to  CET . docker run -it --name run_b9b0099e \\\n    --volume /storage/erc/abc123:/erc --env TZ=CET \\\n    erc:b9b0099e-9f8d   In addition to the mandatory mount of all compendium files,  bind mounts  MAY be added to replace specific files for  substitution .  The mounts MUST be configured in a list node  bind_mounts  under the root-level node  execution  in the ERC configuration file.\nImplementations SHOULD apply them in the same order as given in the configuration file.\nEach mount MUST include the following nodes:   source : mount source file or directory.  destination : mount target path within the container; MUST be an absolute path.   The binds MUST be configured as read only.  If a list of mounts is configured, it MAY include the mandatory bind mount.   Example: data file replacement with bind mounts  The following example includes an explicit definition of the mandatory mount to  /erc  and an overlay bind mount of a CSV file.  id: b9b0099e-9f8d\nspec_version: 1\nexecution:\n    bind_mounts:\n        - source: '/storage/erc/abc123'\n          destination: /erc\n        - source: /storage/erc/other/input_data/fixed.csv\n          destination: /erc/data.csv \nIt can be translated by an implementation to the following bind string: /storage/compendium/other123/input_data/fixed.csv:/erc/data.csv:ro    More on mounts and binds  See Docker API specification section  Create a container  >  HostConfig  >  Binds / Mounts .",
            "title": "Adjusted execution"
        },
        {
            "location": "/spec/#r-workspaces",
            "text": "ERC support the  R  software environment for statistical computing and graphics.",
            "title": "R workspaces"
        },
        {
            "location": "/spec/#structure",
            "text": "The structure (file names for data, directories, etc.) within the ERC are intentionally unspecified.\nHowever, the content\u2019s structure MAY follow conventions or be based on templates for organizing research artifacts.  If a convention is followed then it SHOULD be referenced in the ERC configuration file as a node  convention  section.\nThe node\u2019s value can be any text string which uniquely identifies a convention, but a URI or URL to either a human-readable description or formal specification is RECOMMENDED.  A non-exhaustive list of potential conventions and guidelines  for R  is as follows:   ROpenSci rrrpkg  Jeff Hollister\u2019s manuscriptPackage  Carl Boettiger\u2019s template  Francisco Rodriguez-Sanchez\u2019s template  Ben Marwick\u2019s template  Karl Broman\u2019s comments on reproducibility  R package: \u201cWriting R Extensions\u201d    Example for using the ROPenSci  rrrpkg  convention  The convention is identified using the public link on GitHub. id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nconvention: https://github.com/ropensci/rrrpkg",
            "title": "Structure"
        },
        {
            "location": "/spec/#r-markdown-main-file",
            "text": "The ERC\u2019s  main file  for R-based analyses SHOULD be  R Markdown .  If the main file is R Markdown, it SHOULD include basic metadata in its  YAML front matter : author(s), title, date, et cetera.  The main document SHOULD NOT contain code that loads pre-computed results from files, but conduct all analyses, even costly ones, during document weaving.  The document MUST NOT use  cache=TRUE  on any of the code chunks (see  knitr  options .\nWhile the previously cached files ( .rdb  and  .rdx ) MAY be included, they SHOULD NOT be used during the rendering of the document.   Note  A popular alternative solution is  Sweave  with the  .Rnw  extension, which is still widely used for vignettes. R Markdown was chosen of LaTex for its simplicity for users who are unfamiliar with LaTeX.",
            "title": "R Markdown main file"
        },
        {
            "location": "/spec/#fixing-the-environment-in-code",
            "text": "The time zone MUST be fixed to  UTC   Coordinated Universal Time ) to allow validation of output times (potentially broken by different output formats) by using the following code within the RMarkdown document, or other code to that effect.  Sys.setenv(\"TZ\" = \"UTC\")  The manifest file (i.e.  Dockerfile ) MUST run a plain R session without loading  .RData  files or profiles at startup, i.e. use  R --vanilla .",
            "title": "Fixing the environment in code"
        },
        {
            "location": "/spec/#interactive-erc",
            "text": "Enabling interaction with the contents of an ERC is a crucial goal of this specification (see  Preface ).\nTherefore this section defines metadata to support two goals:   aide  inspecting  users to identify core functions and parameters of an analysis, and  allow supporting software tools to create interactive renderings of ERC contents for  manipulation .   These goals are manifested in the  UI bindings  as part of the ERC configuration file under the root level property  ui_bindings .  An ERC MUST denote if UI bindings are present using the boolean property  interactive .\nIf the property is missing it defaults to  false .\nAn implementation MAY use the indicator  interactive: true  to provide other means of displaying the display file.   Example for minimal interaction configuration  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nui_bindings:\n  interactive: true   An ERC MAY embed multiple concrete UI bindings.\nEach UI binding is represented by a YAML dictionary.  It MUST comprise a purpose and a widget using the fields  purpose  respectively  widget  (both of type string).\nThe values of these fields SHOULD use a concept of an ontology to clearly identify their meaning.  A  purpose  defines the user\u2019s intention, for example  manipulating  a variable or  inspecting  dataset or code.\nA  widget  realizes the purpose with a concrete interaction paradigm chosen by the author, for example an input slider, a form field, or a button.  For each widget, implementations MAY use the properties  code ,  data , and  text  to further describe how a specific UI binding acts upon the respective part of the ERC.   Example of two UI bindings  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nui_bindings:\n  interactive: true\n  bindings:\n    - purpose: http://.../data-inspection\n      widget: http://.../tabular-browser\n      code: [...]\n      data: [...]\n      text: [...]\n    - purpose: http://.../parameter-manipulation\n      widget: http://.../dropdown",
            "title": "Interactive ERC"
        },
        {
            "location": "/spec/#preservation-of-erc",
            "text": "This section places the ERC in the context of preservation workflows by defining structural information and other metadata that guarantee interpretability and enable the bundling of the complete ERC as a self-contained, archivable digital object.",
            "title": "Preservation of ERC"
        },
        {
            "location": "/spec/#archival-bundle",
            "text": "For the purpose of transferring and storing a complete ERC, it MUST be packaged using the  BagIt File Packaging Format (V0.97)  (BagIt) as the outer container.\nBagIt allows to store and transfer arbitrary content along with minimal metadata as well as checksum based payload validation.  The remainder of this section comprises   a description of the outer container,  a BagIt profile,  a package leaflet, and  secondary metadata files.",
            "title": "Archival bundle"
        },
        {
            "location": "/spec/#bagit-outer-container",
            "text": "The ERC base directory MUST be the BagIt payload directory  data/ .\nThe path to the ERC configuration file subsequently MUST be  <path-to-bag>/data/erc.yml .  The bag metadata file  bagit.txt  MUST contain the case-sensitive label  Is-Executable-Research-Compendium  with the case-insensitive value  true  to mark the bag as the outer container of an ERC.  Implementations SHOULD use this field to identify an ERC.   Example  bagit.txt  Payload-Oxum: 2172457623.43\nBagging-Date: 2016-02-01\nBag-Size: 2 GB\nIs-Executable-Research-Compendium: true    Example file tree for a bagged ERC  \u251c\u2500\u2500 bag-info.txt\n\u251c\u2500\u2500 bagit.txt\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 2016-07-17-sf2.Rmd\n\u2502   \u251c\u2500\u2500 erc.yml\n\u2502   \u251c\u2500\u2500 metadata.json\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 image.tar\n\u251c\u2500\u2500 manifest-md5.txt\n\u2514\u2500\u2500 tagmanifest-md5.txt",
            "title": "BagIt outer container"
        },
        {
            "location": "/spec/#bagit-profile-draft",
            "text": "Note  The elements of the o2r Bagit Profile is yet to be specified.\nThis section is under development.\nCurrent BagIt tools do not include an option to add a BagIt Profile automatically.   A  BagIt Profile  as outlined below would make the requirements more explicit.\nThe BagIt Profiles Specification Draft allows users of BagIt bags to coordinate additional information, attached to bags.  {\n  \"BagIt-Profile-Info\":{\n  \"BagIt-Profile-Identifier\":\"http://o2r.info/erc-bagit-v1.json\",\n  \"Source-Organization\":\"o2r.info\",\n  \"Contact-Name\":\"o2r Team\",\n  \"Contact-Email\":\"o2r@uni-muenster.de\",\n  \"External-Description\":\"BagIt profile for packaging\n        executable research compendia.\",\n  \"Version\":\"1\"\n  },\n  \"Bag-Info\":{\n    \"Contact-Name\":{\n       \"required\":true\n    },\n    \"Contact-Email\":{\n       \"required\":true\n    },\n    \"External-Identifier\":{\n       \"required\":true\n    },\n    \"Bag-Size\":{\n       \"required\":true\n    },\n    \"Payload-Oxum\":{\n       \"required\":true\n    }\n  },\n  \"Manifests-Required\":[\n    \"md5\"\n  ],\n  \"Allow-Fetch.txt\":false,\n  \"Serialization\":\"optional\",\n  \"Accept-Serialization\":[\n     \"application/zip\"\n  ],\n  \"Tag-Manifests-Required\":[\n    \"md5\"\n  ],\n  \"Tag-Files-Required\":[\n     \".erc/metadata.json\",\n     \"erc.yml\"\n  ],\n  \"Accept-BagIt-Version\":[\n     \"0.96\"\n  ]\n}",
            "title": "BagIt profile - DRAFT"
        },
        {
            "location": "/spec/#package-leaflet",
            "text": "Each ERC MUST contain a package leaflet, describing the schemas and standards used. Available schema files are supposed to be included with the ERC, if available (licenses for these schemas may apply).   Example package leaflet  {\n    \"standards_used\": [\n        {\n            \"o2r\": {\n                \"map_description\": \"maps raw extracted metadata to\n                    o2r schema compliant metadata\",\n                \"mode\": \"json\",\n                \"name\": \"o2r\",\n                \"outputfile\": \"metadata_o2r.json\",\n                \"root\": \"\"\n            }\n        },\n        {\n            \"zenodo_sandbox\": {\n                \"map_description\": \"maps o2r schema compliant MD to\n                    Zenodo Sandbox for deposition creation\",\n                \"mode\": \"json\",\n                \"name\": \"zenodo_sandbox\",\n                \"outputfile\": \"metadata_zenodo_sandbox.json\",\n                \"root\": \"metadata\"\n            }\n        }\n    ]\n}   Elements used for each schema standard used are contributed via the MD mapping files in the o2r meta tool suite.",
            "title": "Package leaflet"
        },
        {
            "location": "/spec/#secondary-metadata-files",
            "text": "The ERC as an object can be used in a broad range of cases. For example, it can be an item under review during a journal publication, it can be the actual publication at a workshop or conference or it can be a preserved item in a digital archive. All of these have their own standards and requirements to apply, when it comes to metadata.  These metadata requirements  are not  part of this specification, but the following conventions are made to simplify and coordinate the variety.  Metadata specific to a particular domain or use case MUST replicate the information required for the specific case in an independent file.\nDomain metadata SHOULD follow domain conventions and standards regarding format and encoding of metadata.\nDuplicate information is accepted, because it lowers the entry barrier for domain experts and systems, who can simply pick up a metadata copy in a format known to them.  Metadata documents of specific use cases MUST be stored in a directory  .erc , which is a child-directory of the ERC base directory.  Metadata documents SHOULD be named according to the used standard/model, format/encoding, and version, e.g.  datacite40.xml  or  zenodo_sandbox10.json , and SHOULD use a suitable mime type.",
            "title": "Secondary metadata files"
        },
        {
            "location": "/spec/#requirements-of-secondary-metadata",
            "text": "In order to comply to their governing schemas, secondary metadata must include the mandatory information as set by 3rd party services. While the documentation of this quality is a perpetual task, we have gathered the information most relevant our selection of connected services.  Zenodo   Accepts metadata as  JSON .  Mandatory elements:  Upload Type (e.g. Publication)  Publication Type  Title  Creators  Description  Publication Date  Access Right  License     DataCite (4.0)   Accepts metadata as  XML .  Mandatory elements:  Identifier  Creator  Title  Publisher  Publication Year  Resource Type",
            "title": "Requirements of secondary metadata"
        },
        {
            "location": "/spec/#development-bundle",
            "text": "While complete ERCs are focus of this specification, for collaboration and offline  inspection  it is useful to provide access to parts of the ERC.\nTo support such use cases, a  development bundle  MAY be provided by implementations.\nThis bundle most importantly would not include the  runtime image , which is potentially a large file.  The  development bundle  SHOULD always include the  main file  and (e.g. by choice of the user, or by an implementing platform) MAY include other relevant files for reproduction or editing purposes outside of the runtime environment, such as input data or the  runtime manifest  for manual environment recreation.",
            "title": "Development bundle"
        },
        {
            "location": "/spec/#content-metadata",
            "text": "The current JSON dummy file to visualises the properties. These elements SHOULD be filled out as good as possible in the user interface.  {\n    \"access_right\": \"open\",\n    \"author\": [{\n        \"name\": null,\n        \"affiliation\": [],\n        \"orcid\": null\n    }],\n    \"codefiles\": [],\n    \"community\": \"o2r\",\n    \"depends\": [{\n        \"identifier\": null,\n        \"version\": null,\n        \"packageSystem\": null\n    }],\n    \"description\": null,\n    \"ercIdentifier\": null,\n    \"file\": {\n        \"filename\": null,\n        \"filepath\": null,\n        \"mimetype\": null\n    },\n    \"generatedBy\": null,\n    \"identifier\": {\n        \"doi\": null,\n        \"doiurl\": null,\n        \"reserveddoi\": null\n    },\n  \"inputfiles\": [],\n    \"keywords\": [],\n    \"license\": {\"text\": None,\n            \"data\": None,\n            \"code\": None,\n            \"uibindings\": None,\n            \"md\": None\n            },\n    \"paperLanguage\": [],\n    \"paperSource\": null,\n    \"publicationDate\": null,\n    \"recordDateCreated\": null,\n    \"softwarePaperCitation\": null,\n    \"spatial\": {\n        \"files\": [],\n        \"union\": []\n    },\n    \"temporal\": {\n        \"begin\": null,\n        \"end\": null\n    },\n    \"title\": null,\n    \"upload_type\": \"publication\",\n    \"viewfiles\": []\n}  The path to the o2r metadata file MUST be  <path-to-bag>/data/metadata_raw.json  and the refined version  metadata_o2r.json .",
            "title": "Content metadata"
        },
        {
            "location": "/spec/#description-of-o2r-metadata-properties",
            "text": "access_right   String .  creators   Array of objects .  creators.name   String .  creators.orcid   String .  creators.affiliation   String .  codefiles   Array of strings  List of all files of the recursively parsed workspace that have an extension belonging to a (\u201cR\u201d) codefile.  communities   Array of objects  prepared zenodo MD element  communities[0].identifier   String . Indicating the collection as required in zenodo MD, default \u201co2r\u201d.  depends   Array of objects .  depends.operatingSystem   String .  depends.identifier   String .  depends.packageSystem   String . URL  depends.version   String .  description   String . A text representation conveying the purpose and scope of the asset (the abstract).  displayfile   String . The suggested file for viewing the text of the workspace, i.e. a rendering of the suggested mainfile.  displayfile_candidates   Array of strings . An unsorted list of candidates for displayfiles.  ercIdentifier   String . A universally unique character string associated with the asset as executable research compendium, provided by the o2r service.  identifier   Object .  inputfiles   Array of strings . A compiled list of files from the extracted workspace that is called or used in the extracted code of the workspace.  interaction  TBD  keywords   Array of strings . Tags associated with the asset.  license Object .  License information for the entire ERC.  license.code   String . License information for the code included.  license.data String . License information for the data included.  license.md   String . License information for the metadata included. Should be cc0 to include in catalogues.  license.text String . License information for the text included.  license.uibindings   String . License information for the UI-bindings included.  mainfile   String . The suggested main file of workspace  mainfile_candidates   Array . Unsorted list of mainfile candidates of the workspace.  paperLanguage   Array of strings . List of guessed languages for the workspace.  publication_date   String . The publication date of the paper publication as ISO8601 string.  publication_type   String .  related_identifier   String .  spatial   Object . Spatial information of the workspace.  spatial.files   Array of objects .  spatial.union   Array of objects .  temporal   Object . Aggregated information about the relevant time period of the underlying data sets.  temporal.begin  temporal.end  title  The distinguishing name of the paper publication.  upload_type   String.  Zenodo preset. Defaults to \u201cpublication\u201d.",
            "title": "Description of o2r metadata properties"
        },
        {
            "location": "/spec/#erc-checking",
            "text": "",
            "title": "ERC checking"
        },
        {
            "location": "/spec/#procedure",
            "text": "A core feature ERCs are intended to support is comparing the output of an ERC executions with the original outputs.\nTherefore  checking  an ERC always comprises two steps: the execution and the comparison.  The files included in the comparison are the  comparison set .\nAn implementation MUST communicate the comparison set to the user as part of a check.  Previous to the check, an implementation SHOULD conduct a basic validation of the outer container\u2019s integrity, i.e. check the file hashes.\nThe output of the image execution can be shown to the user to convey detailed information on progress or errors.",
            "title": "Procedure"
        },
        {
            "location": "/spec/#comparison-set-file",
            "text": "The ERC MAY contain a file named  .ercignore  in the base directory to define the comparison set.  Its purpose is to provide a way to efficiently exclude files and directories from  checking .\nIf this file is present, any files and directories within the outer container which match the patterns within the file  .ercignore  will be excluded from the checking process.\nThe check MUST NOT fail when files listed in  .ercignore  are failing comparison.  The file MUST be UTF-8 (without BOM) encoded.\nThe newline-separated patterns in the file MUST be  Unix shell globs .\nFor the purposes of matching, the root of the context is the ERC\u2019s base directory.  Lines starting with  #  are treated as comments and MUST be ignored by implementations.   Example  .ercignore  file  # comment\n.erc\n*/temp*\ndata-old/*    Note  If using  md5  file hashes for comparison, the set could include plain text files, for example the  text/*   media types  (see  IANA\u2019s full list of media types .\nOf course the comparison set should include files which contain results of an analysis.",
            "title": "Comparison set file"
        },
        {
            "location": "/spec/#comparing-plain-text-documents",
            "text": "\u2026",
            "title": "Comparing plain text documents"
        },
        {
            "location": "/spec/#comparing-graphics-and-binary-output",
            "text": "This section outlines possibilities beyond simple comparison and incorporates \u201charder\u201d to compare files and what to do with them, e.g. plots/figures, PDF files, \u2026",
            "title": "Comparing graphics and binary output"
        },
        {
            "location": "/spec/#comprehensive-example-of-ercyml",
            "text": "The following example shows all possible fields of the ERC specification with example values.  id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nmain: paper.rmd\ndisplay: paper.html\nexecution:\n  bind_mounts: ...\nlicenses:\n  code: MIT\n  data: ODbL-1.0\n  text: \"data_licenses_info.pdf\"\n  ui_bindings: CC0-1.0\n  metadata: CC0-1.0\nconvention: https://github.com/ropensci/rrrpkg\nui_bindings:\n  interactive: true\n  bindings:\n    - purpose: http://.../data-inspection\n      widget: http://.../tabular-browser\n      code: [...]\n      data: [...]\n      text: [...]\n    - purpose: http://.../parameter-manipulation\n      widget: http://.../dropdown",
            "title": "Comprehensive example of erc.yml"
        },
        {
            "location": "/user-guide/creation/",
            "text": "User guide: ERC creation\n\u00b6\n\n\nThis user guide comprises instructions how to create an ERC \nby hand\n.\nIt is thus limited to mandatory elements in some places.\nHowever, a fundamental goal of the ERC specification is to be simple enough to allow manual ERC creation as demonstrated in this document.\nIt is supposed to ease the understanding of the ERC especially for the authors of scientific publications.\nFor using tools or services for creation and validation of ERCs, please see the \ndeveloper guide\n.\n\n\n\n\nNote\n\n\nThis is a draft.\nIf you have comments or suggestions please file them in the \nissue tracker\n.\nIf you have explicit changes please fork the \ngit repo\n and submit a pull request.\n\n\n\n\nStep 1: create workspace\n\u00b6\n\n\nDo your research and create something useful that works for you.\n\nThe ERC specification makes no restrictions on the contents of a workspace, but guidelines and best practices do exist and should be followed by users during their research i.e. even before packaging it in an ERC.\n\n\nCode and versioning\n\u00b6\n\n\nIf the base directory contains a script file or source code used to conduct the packaged analysis, we recommend this code is managed using \ndistributed version control\n, see \nsoftware carpentry guidelines\n.\nThe base directory should contain a copy of the complete repository in that case.\n\n\nWorkspace structure\n\u00b6\n\n\nThe base directory contents should follow common guidelines to project organisation.\nSome useful resources are\n\n\n\n\nSoftware carpentry paper \u201cGood enough practices in Scientific Computing\u201d\n\n\nROpenSci research compendium\n).\n\n\nROpenSci reproducibility guide\n\n\n\n\nStep 2: create image container for runtime\n\u00b6\n\n\nTo create a working ERC you must include a complete environment description and an executable image.\n\n\nWe recommend using Docker, so a Dockerfile and a Docker image tarball archive file, to achieve these goals.\n\n\nSee the \nruntime section\n for detailed requirements, including links to the relevant Docker commands.\n\n\nStep 3: create metadata\n\u00b6\n\n\nERC metadata\n\u00b6\n\n\nStructural & administrative metadata must be put into the ERC configuration file \nerc.yml\n as defined in the \nspecification\n.\n\n\nWhen creating the erc manually, you can receive a uuid4 as \nid\n for the erc configuration file using an online service, e.g. \nuuidgenerator\n or one of the numerous implementations for the common programming languages.\n\n\nLicense metadata\n\u00b6\n\n\nPlease consult your employer or legal department for a suitable license for your work. Make sure you hold the copyright for any code that you want to release under a self-chosen license.\n\n\nFurther resources that are linked here without any endorsement or being checked:\n\n\n\n\nchoosealicense.com\n (for code)\n\n\nopendefinition.org\n (for code, data, text)\n\n\nA short lecture on Open Licensing by Lorena A. Barba\n\n\n\n\nLicense information must be put into the ERC configuration file \nerc.yml\n as defined in the \nspecification\n.\n\n\nContent metadata\n\u00b6\n\n\nContent metadata are used for making your work findable.\nProperties for the content metadata are defined in the \nspecification\n and must be put into the \nmetadata.json\n file.\n\n\nSecondary metadata\n\u00b6\n\n\nAs of now, we do not recommend creating secondary metadata by hand.\n\n\nSecondary metadata are used for third party services, e.g. repositories that define their own obligatory metadata.\nIn general they can be added in different formats to support different use cases.\n\n\nMore information on secondary metadata can be found in the \npreservation section\n.\n\n\nStep 4: validate\n\u00b6\n\n\nYou can use the container created in step 2 for validation purposes, too.\nRun the analysis in the container, then copy the analysis output to a temporary directory on the host system, and finally compare the original workspace and the temporary directory according the \nvalidation rules\n to ensure a complete replication.\n\n\nStep 5: create bag\n\u00b6\n\n\nTo create a package that is suitable for being stored in an archive or repository, ERCs must be bundled as BagIt bags.\nTake a look at the \npreservation section\n for a detailed background about the purpose of BagIt and other digital preservation aspects.\n\n\nThird party tools for creating BagIt bags\n\u00b6\n\n\n\n\nBagger\n (version 2.7, Java-based, with UI)\n\n\nbagit-python\n (Python package)\n\n\n\n\nCreating the bag\n\u00b6\n\n\nIn this guide we will create the bag manually by using the Library of Congress\u2019s (LoC) tool \nBagger\n, listed above.\n\n\n\n\nStart by selecting \u201cCreate new bag\u201d from the main menu and proceed with \u201c<no profile>\u201c.\n\n\nAdd your files with the \u201c+\u201d Button.\n\n\nUncheck the \u201cStandard\u201d feature in the Bag-Info-Editor on the right and add \nERC-Version\n with the appropriate version you want to use, e.g. \n1\n. Optionally fill out additional Bag-Info metadata, e.g. \ncontact information\n.\n\n\nSave your bag using the main menu.\n\n\n\n\nValidating the bag\n\u00b6\n\n\nA file tree for the final bagged ERC may look like this:\n\n\n\u251c\u2500\u2500 bag-info.txt\n\u251c\u2500\u2500 bagit.txt\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2016-07-17-myPaper.Rmd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 erc.yml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metadata.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 image.tar\n\u251c\u2500\u2500 manifest-md5.txt\n\u2514\u2500\u2500 tagmanifest-md5.txt\n\n\n\nYou can validate your bag with \nBagger\n by loading the bag and then clicking on \u201cValidate Bag\u201d in the main menu.\nThe programme will check for completeness of BagIt-related files and verify the integrity of the data files by computing their checksums (hashes) and report any potential issues.",
            "title": "Creation guide for authors"
        },
        {
            "location": "/user-guide/creation/#user-guide-erc-creation",
            "text": "This user guide comprises instructions how to create an ERC  by hand .\nIt is thus limited to mandatory elements in some places.\nHowever, a fundamental goal of the ERC specification is to be simple enough to allow manual ERC creation as demonstrated in this document.\nIt is supposed to ease the understanding of the ERC especially for the authors of scientific publications.\nFor using tools or services for creation and validation of ERCs, please see the  developer guide .   Note  This is a draft.\nIf you have comments or suggestions please file them in the  issue tracker .\nIf you have explicit changes please fork the  git repo  and submit a pull request.",
            "title": "User guide: ERC creation"
        },
        {
            "location": "/user-guide/creation/#step-1-create-workspace",
            "text": "Do your research and create something useful that works for you. \nThe ERC specification makes no restrictions on the contents of a workspace, but guidelines and best practices do exist and should be followed by users during their research i.e. even before packaging it in an ERC.",
            "title": "Step 1: create workspace"
        },
        {
            "location": "/user-guide/creation/#code-and-versioning",
            "text": "If the base directory contains a script file or source code used to conduct the packaged analysis, we recommend this code is managed using  distributed version control , see  software carpentry guidelines .\nThe base directory should contain a copy of the complete repository in that case.",
            "title": "Code and versioning"
        },
        {
            "location": "/user-guide/creation/#workspace-structure",
            "text": "The base directory contents should follow common guidelines to project organisation.\nSome useful resources are   Software carpentry paper \u201cGood enough practices in Scientific Computing\u201d  ROpenSci research compendium ).  ROpenSci reproducibility guide",
            "title": "Workspace structure"
        },
        {
            "location": "/user-guide/creation/#step-2-create-image-container-for-runtime",
            "text": "To create a working ERC you must include a complete environment description and an executable image.  We recommend using Docker, so a Dockerfile and a Docker image tarball archive file, to achieve these goals.  See the  runtime section  for detailed requirements, including links to the relevant Docker commands.",
            "title": "Step 2: create image container for runtime"
        },
        {
            "location": "/user-guide/creation/#step-3-create-metadata",
            "text": "",
            "title": "Step 3: create metadata"
        },
        {
            "location": "/user-guide/creation/#erc-metadata",
            "text": "Structural & administrative metadata must be put into the ERC configuration file  erc.yml  as defined in the  specification .  When creating the erc manually, you can receive a uuid4 as  id  for the erc configuration file using an online service, e.g.  uuidgenerator  or one of the numerous implementations for the common programming languages.",
            "title": "ERC metadata"
        },
        {
            "location": "/user-guide/creation/#license-metadata",
            "text": "Please consult your employer or legal department for a suitable license for your work. Make sure you hold the copyright for any code that you want to release under a self-chosen license.  Further resources that are linked here without any endorsement or being checked:   choosealicense.com  (for code)  opendefinition.org  (for code, data, text)  A short lecture on Open Licensing by Lorena A. Barba   License information must be put into the ERC configuration file  erc.yml  as defined in the  specification .",
            "title": "License metadata"
        },
        {
            "location": "/user-guide/creation/#content-metadata",
            "text": "Content metadata are used for making your work findable.\nProperties for the content metadata are defined in the  specification  and must be put into the  metadata.json  file.",
            "title": "Content metadata"
        },
        {
            "location": "/user-guide/creation/#secondary-metadata",
            "text": "As of now, we do not recommend creating secondary metadata by hand.  Secondary metadata are used for third party services, e.g. repositories that define their own obligatory metadata.\nIn general they can be added in different formats to support different use cases.  More information on secondary metadata can be found in the  preservation section .",
            "title": "Secondary metadata"
        },
        {
            "location": "/user-guide/creation/#step-4-validate",
            "text": "You can use the container created in step 2 for validation purposes, too.\nRun the analysis in the container, then copy the analysis output to a temporary directory on the host system, and finally compare the original workspace and the temporary directory according the  validation rules  to ensure a complete replication.",
            "title": "Step 4: validate"
        },
        {
            "location": "/user-guide/creation/#step-5-create-bag",
            "text": "To create a package that is suitable for being stored in an archive or repository, ERCs must be bundled as BagIt bags.\nTake a look at the  preservation section  for a detailed background about the purpose of BagIt and other digital preservation aspects.",
            "title": "Step 5: create bag"
        },
        {
            "location": "/user-guide/creation/#third-party-tools-for-creating-bagit-bags",
            "text": "Bagger  (version 2.7, Java-based, with UI)  bagit-python  (Python package)",
            "title": "Third party tools for creating BagIt bags"
        },
        {
            "location": "/user-guide/creation/#creating-the-bag",
            "text": "In this guide we will create the bag manually by using the Library of Congress\u2019s (LoC) tool  Bagger , listed above.   Start by selecting \u201cCreate new bag\u201d from the main menu and proceed with \u201c<no profile>\u201c.  Add your files with the \u201c+\u201d Button.  Uncheck the \u201cStandard\u201d feature in the Bag-Info-Editor on the right and add  ERC-Version  with the appropriate version you want to use, e.g.  1 . Optionally fill out additional Bag-Info metadata, e.g.  contact information .  Save your bag using the main menu.",
            "title": "Creating the bag"
        },
        {
            "location": "/user-guide/creation/#validating-the-bag",
            "text": "A file tree for the final bagged ERC may look like this:  \u251c\u2500\u2500 bag-info.txt\n\u251c\u2500\u2500 bagit.txt\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2016-07-17-myPaper.Rmd\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 erc.yml\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metadata.json\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 image.tar\n\u251c\u2500\u2500 manifest-md5.txt\n\u2514\u2500\u2500 tagmanifest-md5.txt  You can validate your bag with  Bagger  by loading the bag and then clicking on \u201cValidate Bag\u201d in the main menu.\nThe programme will check for completeness of BagIt-related files and verify the integrity of the data files by computing their checksums (hashes) and report any potential issues.",
            "title": "Validating the bag"
        },
        {
            "location": "/user-guide/examination/",
            "text": "User guide: ERC examination\n\u00b6\n\n\nUI-based\n\u00b6\n\n\nTBD\n\n\nManual\n\u00b6\n\n\n\n\nuntar\n\n\nimage metadata\n\n\nstructure of image tarball",
            "title": "Examination guide for authors"
        },
        {
            "location": "/user-guide/examination/#user-guide-erc-examination",
            "text": "",
            "title": "User guide: ERC examination"
        },
        {
            "location": "/user-guide/examination/#ui-based",
            "text": "TBD",
            "title": "UI-based"
        },
        {
            "location": "/user-guide/examination/#manual",
            "text": "untar  image metadata  structure of image tarball",
            "title": "Manual"
        },
        {
            "location": "/user-guide/template/",
            "text": "User guide: ERC template - WORK IN PROGRESS\n\u00b6\n\n\nIf you want to create an ERC for your research already at the beginning, and not \u201cpost-hoc\u201d after your research is complete, these templates can hopefully help.\nThey are divided into specific domains to be more concrete.\n\n\nGeoscience research in R\n\u00b6\n\n\nFiles in this template\n\n\n\n\ndocument.md\n use RMarkdown, this is the main document\n\n\nerc.yml\n is template for the ERC configuration file with placeholders for all required fields\n\n\nDockerfile\n is a template Dockerfile with some commands you can re-use to make sure all packages and tools that you need are installed\n\n\n\n\nHeader template\n\u00b6\n\n\nThe yaml header of the \ndocument.md\n file is the right place to enter your meta information right away from the start: Fill out the metadata fields, included in the template, as early in your personal workflow as possible and keep them up-to-date to prepare for the ERC creation progress. The metadata extractor of the o2r service will collect and prefer information from RMarkdown document headers.\n\n\n---\nauthor:\n  - name: Your Name\n    affiliation: Your affiliation\n    orcid: Your ORCid\n  - name: Your co-author's name\n    affiliation: Their affiliation\n    orcid: Their ORCid\ntitle: The title of your publication\nabstract:\n  A concise description of your publication\nkeywords: [lorem, ipsum, dolor, sit, amet]\ndate: 2017-01-13\nlicense: cc-by\n---\n\n\n\nFilename\n | \nTemplate\n | \nERC-Spec\n \n------ | ------ | ------ |\n\ngeo_template.zip\n | Geoscience research in R | V.1",
            "title": "ERC template for authors"
        },
        {
            "location": "/user-guide/template/#user-guide-erc-template-work-in-progress",
            "text": "If you want to create an ERC for your research already at the beginning, and not \u201cpost-hoc\u201d after your research is complete, these templates can hopefully help.\nThey are divided into specific domains to be more concrete.",
            "title": "User guide: ERC template - WORK IN PROGRESS"
        },
        {
            "location": "/user-guide/template/#geoscience-research-in-r",
            "text": "Files in this template   document.md  use RMarkdown, this is the main document  erc.yml  is template for the ERC configuration file with placeholders for all required fields  Dockerfile  is a template Dockerfile with some commands you can re-use to make sure all packages and tools that you need are installed",
            "title": "Geoscience research in R"
        },
        {
            "location": "/user-guide/template/#header-template",
            "text": "The yaml header of the  document.md  file is the right place to enter your meta information right away from the start: Fill out the metadata fields, included in the template, as early in your personal workflow as possible and keep them up-to-date to prepare for the ERC creation progress. The metadata extractor of the o2r service will collect and prefer information from RMarkdown document headers.  ---\nauthor:\n  - name: Your Name\n    affiliation: Your affiliation\n    orcid: Your ORCid\n  - name: Your co-author's name\n    affiliation: Their affiliation\n    orcid: Their ORCid\ntitle: The title of your publication\nabstract:\n  A concise description of your publication\nkeywords: [lorem, ipsum, dolor, sit, amet]\ndate: 2017-01-13\nlicense: cc-by\n---  Filename  |  Template  |  ERC-Spec  \n------ | ------ | ------ | geo_template.zip  | Geoscience research in R | V.1",
            "title": "Header template"
        },
        {
            "location": "/user-guide/minimal/",
            "text": "Minimal examples for ERCs\n\u00b6\n\n\n\n\nR script with png plot\n\n\nR Markdown with HTML output\n\n\n\n\nR script with png plot\n\u00b6\n\n\nMain file \nmain.R\n\u00b6\n\n\n# http://www.budgetshippingcontainers.co.uk/info/\n# how-many-shipping-containers-are-there-in-the-world/\ncontainers <- c(23000000,14000000,6000000)\nset.seed(42)\nbarplot(containers,\n    names.arg = c(\"in service\", \"ex-service\", \"new\"),\n    col = sample(colors(), 3),\n    main = paste0(\n        format(sum(containers), scientific = FALSE),\n        \" containers in the world\")\n    )\n\n\n\nDisplay file \ndisplay.png\n\u00b6\n\n\n\n\nERC configuration file\n\u00b6\n\n\n---\nid: \"289a9jcl9o\"\nspec_version: \"1\"\nmain: main.R\ndisplay: display.png\n\n\n\nR Markdown with HTML output\n\u00b6\n\n\nMain file \nmain.Rmd\n\u00b6\n\n\n---\ntitle: \"Capacity of container ships in seaborne trade from 1980 to 2016 (in million dwt)*\"\nauthor: \"Daniel N\u00fcst\"\ndate: \"2017\"\noutput: html_document\n---\n\n```{r plot, echo=FALSE}\ndata <- c(\"1980\" = 11, \"1985\" = 20, \"1990\" = 26, \"1995\" = 44,\n          \"2000\" = 64, \"2005\" = 98, \"2010\" = 169, \"2014\" = 216,\n          \"2015\" = 228, \"2016\" = 244)\nbarplot(data, ylab = \"Capacity\", sub = \"\u00a9 Statista 2017\")\n```\n\n> This statistic portrays the capacity of the world container ship fleet from 1980 through 2016. In 2016, the world merchant container ship fleet had a capacity of around 244 million metric tons deadweight. As of January 2016, there were 5,239 container ships in the world's merchant fleet ([source](https://www.statista.com/statistics/264024/number-of-merchant-ships-worldwide-by-type/)).\n\nSources: UNCTAD; Clarkson Research Services, via [statista](https://www.statista.com/statistics/267603/capacity-of-container-ships-in-the-global-seaborne-trade/).\n\n\n\nDisplay file \ndisplay.html\n\u00b6\n\n\n\n\n\nHTML\n\n\nERC configuration file\n\u00b6\n\n\n---\nid: \"v97cplst6b\"\nspec_version: \"1\"\nmain: main.Rmd\ndisplay: display.html",
            "title": "Minimal ERC examples"
        },
        {
            "location": "/user-guide/minimal/#minimal-examples-for-ercs",
            "text": "R script with png plot  R Markdown with HTML output",
            "title": "Minimal examples for ERCs"
        },
        {
            "location": "/user-guide/minimal/#r-script-with-png-plot",
            "text": "",
            "title": "R script with png plot"
        },
        {
            "location": "/user-guide/minimal/#main-file-mainr",
            "text": "# http://www.budgetshippingcontainers.co.uk/info/\n# how-many-shipping-containers-are-there-in-the-world/\ncontainers <- c(23000000,14000000,6000000)\nset.seed(42)\nbarplot(containers,\n    names.arg = c(\"in service\", \"ex-service\", \"new\"),\n    col = sample(colors(), 3),\n    main = paste0(\n        format(sum(containers), scientific = FALSE),\n        \" containers in the world\")\n    )",
            "title": "Main file main.R"
        },
        {
            "location": "/user-guide/minimal/#display-file-displaypng",
            "text": "",
            "title": "Display file display.png"
        },
        {
            "location": "/user-guide/minimal/#erc-configuration-file",
            "text": "---\nid: \"289a9jcl9o\"\nspec_version: \"1\"\nmain: main.R\ndisplay: display.png",
            "title": "ERC configuration file"
        },
        {
            "location": "/user-guide/minimal/#r-markdown-with-html-output",
            "text": "",
            "title": "R Markdown with HTML output"
        },
        {
            "location": "/user-guide/minimal/#main-file-mainrmd",
            "text": "---\ntitle: \"Capacity of container ships in seaborne trade from 1980 to 2016 (in million dwt)*\"\nauthor: \"Daniel N\u00fcst\"\ndate: \"2017\"\noutput: html_document\n---\n\n```{r plot, echo=FALSE}\ndata <- c(\"1980\" = 11, \"1985\" = 20, \"1990\" = 26, \"1995\" = 44,\n          \"2000\" = 64, \"2005\" = 98, \"2010\" = 169, \"2014\" = 216,\n          \"2015\" = 228, \"2016\" = 244)\nbarplot(data, ylab = \"Capacity\", sub = \"\u00a9 Statista 2017\")\n```\n\n> This statistic portrays the capacity of the world container ship fleet from 1980 through 2016. In 2016, the world merchant container ship fleet had a capacity of around 244 million metric tons deadweight. As of January 2016, there were 5,239 container ships in the world's merchant fleet ([source](https://www.statista.com/statistics/264024/number-of-merchant-ships-worldwide-by-type/)).\n\nSources: UNCTAD; Clarkson Research Services, via [statista](https://www.statista.com/statistics/267603/capacity-of-container-ships-in-the-global-seaborne-trade/).",
            "title": "Main file main.Rmd"
        },
        {
            "location": "/user-guide/minimal/#display-file-displayhtml",
            "text": "HTML",
            "title": "Display file display.html"
        },
        {
            "location": "/user-guide/minimal/#erc-configuration-file_1",
            "text": "---\nid: \"v97cplst6b\"\nspec_version: \"1\"\nmain: main.Rmd\ndisplay: display.html",
            "title": "ERC configuration file"
        },
        {
            "location": "/user-guide/oais/",
            "text": "ERC preservation aspects in the light of OAIS\n\u00b6\n\n\nThe Open Archival Information System (OAIS) reference model is a framework for the preservation and dissemination of digital objects (assets). It has been created by the Consultative Committee for Space Data Systems (CCSDS) and has since been adopted by a wide range of international institutions. The OAIS provides the terminology and concept of the \ninformation package\n as primitive of the digital preservation workflow. Submission information packages (SIP), Dissemination information packages (DIP) and Archival information packages (AIP) refer to different functional roles and stages of a digital object within long term preservation.\n\n\nWhere does the ERC fit into long term preservation? ERCs contain software. They could be abstracted as recipes for the reproduction of a scientific analysis be it a stand alone version or a supplement for a scholarly paper. As such every ERC has a bit stream aspect and is suitable for digital preservation in general.\n\n\nBut the ERC was also specifically designed to be represented as an information package in the sense of the OAIS model: the data inside the ERC are valid Bagit bags, making it easy to validate their bitwise integrity with checksums. Additionally the ERC comprises several facets of metadata and a governing \u201cpackage slip\u201d that preserves the standards and schemas used for these metadata. The elicitation of metadata as well as the creation of valid Bagit bags are fully integrated into the creation process of the ERC.\n\n\nInterpretability of the archived software\n\u00b6\n\n\nThe representation information object within OAIS consists of structural and semantic information and is itself linked to other units of representation information, building a representation network. The information contained within the ERC and its metadata serves as representation information and enables the interpretability of the archived software, environment, code, data, text and UI bindings. Standards used for representation are included as local copy of the underlying schema and as reference to their persistent identifiers. The network of information objects describes how the parts of the ERC relate to each other and how they are to be used and understood.\n\n\nBy providing a \u201cpackage slip\u201d for the standards and schemas used in the ERC a vital step for the preservation of software interpretability is completed. As the ERC is designed to transport every information necessary to recreate the original piece of software as represented by a scientific workspace to serve as supplement for a publication or as a repository publication itself, there is often several metadata standards involved (e.g. Datacite, Codemeta, \u2026). The long term interpretability of these information is ensured by including the metadata and their governing schemas on a second order meta level. They allow for interpreting the original data, but also the semantics of the metadata elements describing the original data assets.\n\n\nThe concept of archival interpretability adds significant scientific value as it enables multi-level reproducibility and addionally a future historical perspective on the scientific analysis of today.\n\n\nReferences\n\u00b6\n\n\n\n\nCCSDS (2012): RECOMMENDED PRACTICE FOR AN OAIS REFERENCE MODEL. CCSDS 650.0-M-2 (Magenta Book). \nhttp://public.ccsds.org/publications/archive/650x0m2.pdf\n\n\nMaack, M.N. (2015). The Open Archival Information System (oais) Reference Model.",
            "title": "ERC & OAIS"
        },
        {
            "location": "/user-guide/oais/#erc-preservation-aspects-in-the-light-of-oais",
            "text": "The Open Archival Information System (OAIS) reference model is a framework for the preservation and dissemination of digital objects (assets). It has been created by the Consultative Committee for Space Data Systems (CCSDS) and has since been adopted by a wide range of international institutions. The OAIS provides the terminology and concept of the  information package  as primitive of the digital preservation workflow. Submission information packages (SIP), Dissemination information packages (DIP) and Archival information packages (AIP) refer to different functional roles and stages of a digital object within long term preservation.  Where does the ERC fit into long term preservation? ERCs contain software. They could be abstracted as recipes for the reproduction of a scientific analysis be it a stand alone version or a supplement for a scholarly paper. As such every ERC has a bit stream aspect and is suitable for digital preservation in general.  But the ERC was also specifically designed to be represented as an information package in the sense of the OAIS model: the data inside the ERC are valid Bagit bags, making it easy to validate their bitwise integrity with checksums. Additionally the ERC comprises several facets of metadata and a governing \u201cpackage slip\u201d that preserves the standards and schemas used for these metadata. The elicitation of metadata as well as the creation of valid Bagit bags are fully integrated into the creation process of the ERC.",
            "title": "ERC preservation aspects in the light of OAIS"
        },
        {
            "location": "/user-guide/oais/#interpretability-of-the-archived-software",
            "text": "The representation information object within OAIS consists of structural and semantic information and is itself linked to other units of representation information, building a representation network. The information contained within the ERC and its metadata serves as representation information and enables the interpretability of the archived software, environment, code, data, text and UI bindings. Standards used for representation are included as local copy of the underlying schema and as reference to their persistent identifiers. The network of information objects describes how the parts of the ERC relate to each other and how they are to be used and understood.  By providing a \u201cpackage slip\u201d for the standards and schemas used in the ERC a vital step for the preservation of software interpretability is completed. As the ERC is designed to transport every information necessary to recreate the original piece of software as represented by a scientific workspace to serve as supplement for a publication or as a repository publication itself, there is often several metadata standards involved (e.g. Datacite, Codemeta, \u2026). The long term interpretability of these information is ensured by including the metadata and their governing schemas on a second order meta level. They allow for interpreting the original data, but also the semantics of the metadata elements describing the original data assets.  The concept of archival interpretability adds significant scientific value as it enables multi-level reproducibility and addionally a future historical perspective on the scientific analysis of today.",
            "title": "Interpretability of the archived software"
        },
        {
            "location": "/user-guide/oais/#references",
            "text": "CCSDS (2012): RECOMMENDED PRACTICE FOR AN OAIS REFERENCE MODEL. CCSDS 650.0-M-2 (Magenta Book).  http://public.ccsds.org/publications/archive/650x0m2.pdf  Maack, M.N. (2015). The Open Archival Information System (oais) Reference Model.",
            "title": "References"
        },
        {
            "location": "/user-guide/erc_journal_supplement/",
            "text": "User guide: the ERC as journal supplement\n\u00b6\n\n\nTo facilitate integration into open access journals, the ERC can serve as a supplement for a journal article.\nIn that use case a supplement would not contain the full text of the publication but be attached to / linked from and article instead.\nWhile this increases storage size (each ERC must contain all required data and software), introduces duplication (e.g. in the metadata) and spreads out related artifacts (e.g. if each supplement is stored in an independent repository item), it considerably simplifies integration with existing workflows and practices, e.g. by licensing and storing the supplemental material independently from the article, and by not impacting the existing article rendering solution (e.g. static HTML or PDF).\n\n\nWhen the ERC is attached as supplement, it is important to make sure the results are still findable, accessible, interoperable, and reusable, following the FAIR principles.\nA supplemental ERC should most importantly reference the main article via its DOI.\n\n\nAn ERC as supplement must still be a formally complete ERC and as such it satisfies important requirements of reproducible research.\n\n\n\n\nExample\n\n\nA publication contains three figures with data plots.\nTwo approaches are possible:\n\n\n\n\neach of the figures is encapsulated in a minimal ERC containing the needed data, an R script, the rendered figure as a grphic (e.g. a PNG), and its own runtime environment; or\n\n\nall figures are embedded in an R Markdown document, including the article abstract, figure titles, and figure description, and share data files and the runtime environment.\n\n\n\n\nThe latter approach is more user friendly because explanatory context is provided and the HTML-based display file directly supports UI bindings.\n\n\n\n\nRead more on the increasing importance of reproducible supplements scientific records in\n\nGreenbaum et al. 2017\n.",
            "title": "ERC as supplement"
        },
        {
            "location": "/user-guide/erc_journal_supplement/#user-guide-the-erc-as-journal-supplement",
            "text": "To facilitate integration into open access journals, the ERC can serve as a supplement for a journal article.\nIn that use case a supplement would not contain the full text of the publication but be attached to / linked from and article instead.\nWhile this increases storage size (each ERC must contain all required data and software), introduces duplication (e.g. in the metadata) and spreads out related artifacts (e.g. if each supplement is stored in an independent repository item), it considerably simplifies integration with existing workflows and practices, e.g. by licensing and storing the supplemental material independently from the article, and by not impacting the existing article rendering solution (e.g. static HTML or PDF).  When the ERC is attached as supplement, it is important to make sure the results are still findable, accessible, interoperable, and reusable, following the FAIR principles.\nA supplemental ERC should most importantly reference the main article via its DOI.  An ERC as supplement must still be a formally complete ERC and as such it satisfies important requirements of reproducible research.   Example  A publication contains three figures with data plots.\nTwo approaches are possible:   each of the figures is encapsulated in a minimal ERC containing the needed data, an R script, the rendered figure as a grphic (e.g. a PNG), and its own runtime environment; or  all figures are embedded in an R Markdown document, including the article abstract, figure titles, and figure description, and share data files and the runtime environment.   The latter approach is more user friendly because explanatory context is provided and the HTML-based display file directly supports UI bindings.   Read more on the increasing importance of reproducible supplements scientific records in Greenbaum et al. 2017 .",
            "title": "User guide: the ERC as journal supplement"
        },
        {
            "location": "/dev-guide/",
            "text": "ERC developer guide\n\u00b6\n\n\nAn introduction to the ERC rational and the technology choices made within the project \nOpening Reproducible Research\n (o2r), and ideas for downstream products based on ERCs.\nThis documents is targeted at \ndevelopers\n who wish to create tools for creating, validating, and consuming ERC or who wonder about why specific tools or approaches were taken in designing the ERC specification.\n\n\nMore information about the software developed by o2r:\n\n\n\n\no2r Web API specification\n\n\no2r Architecture documentation\n\n\no2r Reference Implementation\n\n\n\n\n\n\nNote\n\n\nThis guide is a draft. If you have comments or suggestions please file them in the \nissue tracker\n. If you have explicit changes please fork the \ngit repo\n and submit a pull request.\n\n\n\n\nConvention over configuration and DevOps\n\u00b6\n\n\nThe ERC specification is inspired by two approaches to improve development and operation of software.\nFirst,  \n\u201cconvention  over  configuration\u201d\n, e.g. as  practiced  in  the Java build tool \nMaven\n.\n\n\nWe want to create a directory structure with default file names and sensible defaults.\nThis way a typical research workspace should require only minimal configuration in 80% of the cases, while allowing to override each of the settings if need be and providing full customizability in the remaining 20%.\n\n\nFor example, the main command to compile the text manuscript in a compendium could be \nknitr::knit(\"<*>.Rmd\")\n, with \n<*>\n being replaced by name of the first RMarkdown file.\nHowever, if a user wants to use \nrmarkdown::render(..)\n on a file named \npublication.md\n, then the default behaviour can be overwritten.\n\n\nSecond, \n\u201cDevOps\u201d\n, see \nWikipedia\n or \nBoettiger\n.\nAll processing and configuration shall be scripted, no \u201cclick\u201d interaction required.\n\n\nRelated initiatives, specifications, \u2026\n\u00b6\n\n\n\n\nActivePapers\n\n\neLife Reproducible Document Stack\n and the \ndar\n format\n\n\nWhole Tale\n, see its \nserialization format\n\n\nREANA\n by CERN\n\n\n\n\nReasoning and decisions\n\u00b6\n\n\nWhat is the life span of an ERC?\n\u00b6\n\n\nShort answer: 10 years.\n\n\nSoftware that is \u201carchived\u201d is \nnot\n intended to be \u201cused\u201d anymore.\nIn 50 or 60 years time we cannot imagine how software or computers will look like.\nScience historians might still find a lot of valuable information in ERC, though.\n\n\nThe ERC focusses on providing a \nusable environment for research workflows\n in the context of scholarly publishing (reviews etc.).\nTwo aspects have an impact on the time frame we target for ERCs: (a) the nature of financing science and (b) the requirement to actually have a piece of code and data that is still interesting to use.\n\n\nFinancing of scientific research is normally based on projects with a specific life span.\nWe follow common guidelines for \npublishing scientific data\n, which require projects to ensure data availability for 10 years.\n\n\nAlthough much of the software we use today (like R) is actually quite \u201cold\u201d, we do not expect pieces of software that are relevant and useful to disappear for many years and only be preserved in ERCs.\nSo, valuable software will exists and be maintained outside of ERCs.\nSpecific software might only exist in ERCs and can be thoroughly inspected forever, but \npotentially\n not be executed anymore after a decade.\n\n\nWe acknowledge a \nhalf life\n of computations, but the \nmedium term reproducibility of ERC are already a huge improvement\n over \nthe current state\n at the example of research data.\nThe situation for research data might have improved in the last years, but the situation for code is mostly unknown and might be even worse.\n\n\nNotes and decisions to elaborate on\u2026\n\u00b6\n\n\n\n\nresearch workflows with environmental or generated data can be \n\u201cborn digital\n\u201d from beginning and stay that way to the end (sensors, data storage, data analysis, presentation, review, publication)\n\n\nresearchers do their thing and need independence/flexibility, so post-hoc creation will probably be most common and ERC must have low to no impact on workflow\n\n\ndata storage, citation (for giving credit) and preservation is solved (repos, DOIs, bitstream preservation in archives)\n\n\npackaging methods/methodology for software is solved (R packages, Python packages, \u2026)\n\n\nsoftware preservation is \nnot\n solved (methods are there, like migration, emulation, but complexity is too high to do this at high granularity)\n\n\nreproducible paper is somewhat solved (literate programming, R package dependency handling solutions, ..)\n\n\ncomputational RR requires sandboxing (to make sure everything is there, but also for security)\n\n\na service is needed to create ERC for researchers and executes them in a controlled environment\n\n\n\n\nWhy nested containers?\n\u00b6\n\n\nA user shall have access to the files without starting the runtime container.\nTherefore we have at least two items, so we have a bundle and need an outer container.\nAs a bonus, the outer container can immediately be used to make an ERC conform to specific use cases, such as long term archival.\nAlso the chosen outer container solution (zip, tarball) is much older and common than the inner container standard, and thus more likely to exist longer.\n\n\n\n\n\u201cWhat\u2019s oldest lasts longest.\u201d \nsource\n\n\n\n\nWhy your own configuration file?\n\u00b6\n\n\nBecause it gives control and freedom.\nThe ERC has more than one building block, and if we want to make any of them configurable, we need a place to get users as well as tools started, an \u201centrypoint\u201d.\n\n\nWhy not use container labels?\n\n\nThe alternative of putting everything into the container itself (e.g. using image labels for metadata and configuration) can be evaluated in the future.\nThe idea is interesting as labels can be named/grouped with \u201cnamespaces\u201d and could contain more complex information than currently prevalent.\n\n\nSee also \n#19\n.\n\n\nWhy BagIt?\n\u00b6\n\n\n\n\nBagIt is something that preservation experts understand and covers what they care about (bitstream preservation), so it seemed a good fit in the first project vision.\n\n\nBagIt originally was the required packaging for uploading of data, but that has changed. Users upload their data and analysis, and then execute the analysis to ensure the output matches what they created themselves. This is more important than correct bits, which become relevant again after creation of an ERC when it is stored and a bag is created.\n\n\n\n\nWhat about the limitations of containers?\n\u00b6\n\n\nWe are aware of the limitations that containers have.\nMost importantly the operating system and the kernel are not included.\nThis results in smaller container size and better performance (e.g. quicker start because no \u201cboot\u201d) and also has security advantages.\nHowever, it also means that the encapsulated runtime environment in ERCs is \nnot\n \u201call the way down\u201d.\n\n\nIt must be noted that of course changes in the operating system and it\u2019s kernel may break a workflow encapsulated in a container.\n\n\nLet\u2019s consider the \nLinux Kernel\n.\nThose breaking changes are \nvery rare\n.\n\n\nLet\u2019s consider \nDocker\n.\nDocker containers have by now been \nstandardised by the OCI\n and ERCs \nshould rely on the open standard in the future\n (contributions welcome).\nThe \nmaintenance lifecycle\n and \ncompatibility matrix\n of Docker do not imply they are suitable for the targeted time frame for ERCs.\n\n\nHowever, all these projects are Open Source software or documentation, and a long term provider for ERC (i.e. not a small research project) can handle these limitations in different ways, for example \norganisationally\n with long term maintenance contracts or \ntechnically\n as outlined in the o2r architecture \nin the production architecture sketch\n.\nThese include specialised hardware and operating system specifics.\n\n\nWhy Docker?\n\u00b6\n\n\n\n\n(Docker) containers provide an encapsulation mechanism to package all dependencies of an analysis\n\n\nDocker now basically is OCI, so switching to other tools should be possible.\n\n\nduring container execution, and substitution, the build in \ncopy-on-write\n storage only creates copy of files that are changed within the container, thus saving storage capacity\n\n\nvolume mounts allow easy substitution of input data and configurations of analysis\n\n\n\n\nWhy not Singularity?\n\u00b6\n\n\nSingularity\n is an open source containerization solution.\nIt might very well be a better choice for reproducible research in the future as it stems from the scientific community (HPC), cf. also \nC4RR workshop 2017\n.\nAt the point of starting the specification, Docker was more widespread and implementations more readily available.\nFurthermore the origin of Singularity, high performance computing, is out of scope of ERC.\n\n\nWe do not see an issue in not using Singulary.\nMost importantly, the concepts \nruntime manifest\n and \nruntime image\n are abstract, i.e. independent of Docker and the concrete container tool choice could be made flexible in future versions of the specification.\nSingularity can import Docker images and as such make a transition possible, or even let an implementation use Singularity without touch the specification.\n\n\nWhy not just use plain R?\n\u00b6\n\n\nIt would be possible to rely solely on R for replication.\nFor example, the runtime manifest could be a \ncodemeta\n document, and the runtime environment is created based on it outside of the ERC when needed, for example by installing R in the required version.\nAdditionally a package for preserving a state of dependencies could be used, e.g. \npackrat\n.\nThis solution is potentially less storage intensive, because containers replicate an R installation each time.\nSmaller storages might also ease collaboration.\n\n\nHowever, none of these solutions touches the underlying system libraries.\nThe complexity of preserving the runtime environment is transferred from the packaging stage to the unpackaging stage, which is unfavourable because that packaging state \u201ceverything works\u201d, so better control is ensured at that time.\nThe burden in a plain R solution shifts from authoring to preservation.\n\n\nEven though shipping system binaries within packages is possible (if not common), some packages do use system libraries which are not preserved in a plain R approach.\nAdjusting such packages is not an option.\n\n\nFurthermore, none of the solutions for reproducibility are part of \u201ccore R\u201d, even if they are trustworthy (e.g. MRAN).\nCRAN does not support installing specific package versions.\n\n\nThat is why using an abstraction layer outside of R is preferable.\n\n\nWhat if licensing information is not detailed enough?\n\u00b6\n\n\nWithout proper license credits, the contents of an ERC would be useless based on today\u2019s copyright laws.\nTherefore we rather have the extra work for authors to define a couple of licenses than to create something that is unusable by others.\n\n\nOne of the biggest issues is the \nscope of licenses\n, namely what to do about having multiple pieces of code, text, or data with different licenses.\n\n\nIdeas/Notes\n\n\nThe \nerc.yml\n could also hold more complex license metadata, for specific directories or files.\nProbably this is better solved in specialised formats, though.\n\n\n\n\nExample using specific licenses\n\n\n---\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n  code:\n    others_lib.bin: MIT\n    my_code.c: GPL-3.0\n  data: \n    facts.csv: ODbL-1.0\n  text:\n    README.md: CC0-1.0\n        paper.Rmd: CC-BY-4.0\n      ui_bindings: CC0-1.0\n      metadata: CC0-1.0\n\n\n\n\n\nIt could even be possible to assign one license to a directory and override that assignment for a single file within that directory, or use globs or regular expressions.\n\n\nWhy (not) put \u201cX\u201d into the ERC configuration file?\n\u00b6\n\n\n\n\nidentifier\n\n\nmakes it easier to track across platforms\n\n\nis harder for manual creation\n\n\n\n\n\n\nkernel\n\n\nwould have to use our own label within image metadata\n\n\n\n\n\n\nos and architecture\n\n\nare already clearly defined im image spec\n\n\ncan be extracted from a plain text file in the image tarball, so implementations can get them (quickly) before loading an image (a potentially costly operation)\n\n\n\n\n\n\nDocker version\n\n\nis already clearly defined in image spec\n\n\n\n\n\n\n\n\nWhy is validation happening outside the container and not \nin\n the container?\n\u00b6\n\n\n\n\nbetter user experience (otherwise all info must be transported via stdout)\n\n\nto be sure nothing is manipulated within the validation script\n\n\n\n\nWhy is the data not in the image (inner container) but in the outer container?\n\u00b6\n\n\n\n\nbetter accessible in the long term\n\n\nno data duplication\n\n\n\n\nERC completeness score\n\u00b6\n\n\nWhile the ERC is intended to be simple enough to be created manually, the clear requirements on it\u2019s contents also serve a semi-automatic creation.\nFor example, a user can upload a workspace with data files, and R Markdown document, and an HTML rendering of the document to an online platform, where the runtime manifest and image are automatically created. In such a case, metadata would still be added manually.\n\n\nTo encourage users, especially during the manual steps of the creation process, to provide valuable input a \ncompleteness score\n can be useful.\nComparable to profile editors on social network sites, a percentage based score can be used to highlight content or aspects going beyond the mandatory requirements.\n\n\nImplementing platforms may create their own rules, for example which of the optional metadata elements contribute towards reaching a full score.\nThinking beyond merely the metadata, the score could also cover the runtime manifest (e.g. does it follow common practices, include relevant independent metadata, uses explicit versioning for dependency installation), contained code (e.g. automatic checks against code formatting guidelines, syntactical errors), and contained data (e.g. are open file formats used, maybe rewarding CSV over Shapefiles).\n\n\nA completeness score can be seen as a \ndownstream product\n based on the ERC.\nIt is unlikely this ever makes it into an ERC specification, but it can be a crucial means towards acceptance, adoption, and success of ERCs.",
            "title": "Developer guide"
        },
        {
            "location": "/dev-guide/#erc-developer-guide",
            "text": "An introduction to the ERC rational and the technology choices made within the project  Opening Reproducible Research  (o2r), and ideas for downstream products based on ERCs.\nThis documents is targeted at  developers  who wish to create tools for creating, validating, and consuming ERC or who wonder about why specific tools or approaches were taken in designing the ERC specification.  More information about the software developed by o2r:   o2r Web API specification  o2r Architecture documentation  o2r Reference Implementation    Note  This guide is a draft. If you have comments or suggestions please file them in the  issue tracker . If you have explicit changes please fork the  git repo  and submit a pull request.",
            "title": "ERC developer guide"
        },
        {
            "location": "/dev-guide/#convention-over-configuration-and-devops",
            "text": "The ERC specification is inspired by two approaches to improve development and operation of software.\nFirst,   \u201cconvention  over  configuration\u201d , e.g. as  practiced  in  the Java build tool  Maven .  We want to create a directory structure with default file names and sensible defaults.\nThis way a typical research workspace should require only minimal configuration in 80% of the cases, while allowing to override each of the settings if need be and providing full customizability in the remaining 20%.  For example, the main command to compile the text manuscript in a compendium could be  knitr::knit(\"<*>.Rmd\") , with  <*>  being replaced by name of the first RMarkdown file.\nHowever, if a user wants to use  rmarkdown::render(..)  on a file named  publication.md , then the default behaviour can be overwritten.  Second,  \u201cDevOps\u201d , see  Wikipedia  or  Boettiger .\nAll processing and configuration shall be scripted, no \u201cclick\u201d interaction required.",
            "title": "Convention over configuration and DevOps"
        },
        {
            "location": "/dev-guide/#related-initiatives-specifications",
            "text": "ActivePapers  eLife Reproducible Document Stack  and the  dar  format  Whole Tale , see its  serialization format  REANA  by CERN",
            "title": "Related initiatives, specifications, ..."
        },
        {
            "location": "/dev-guide/#reasoning-and-decisions",
            "text": "",
            "title": "Reasoning and decisions"
        },
        {
            "location": "/dev-guide/#what-is-the-life-span-of-an-erc",
            "text": "Short answer: 10 years.  Software that is \u201carchived\u201d is  not  intended to be \u201cused\u201d anymore.\nIn 50 or 60 years time we cannot imagine how software or computers will look like.\nScience historians might still find a lot of valuable information in ERC, though.  The ERC focusses on providing a  usable environment for research workflows  in the context of scholarly publishing (reviews etc.).\nTwo aspects have an impact on the time frame we target for ERCs: (a) the nature of financing science and (b) the requirement to actually have a piece of code and data that is still interesting to use.  Financing of scientific research is normally based on projects with a specific life span.\nWe follow common guidelines for  publishing scientific data , which require projects to ensure data availability for 10 years.  Although much of the software we use today (like R) is actually quite \u201cold\u201d, we do not expect pieces of software that are relevant and useful to disappear for many years and only be preserved in ERCs.\nSo, valuable software will exists and be maintained outside of ERCs.\nSpecific software might only exist in ERCs and can be thoroughly inspected forever, but  potentially  not be executed anymore after a decade.  We acknowledge a  half life  of computations, but the  medium term reproducibility of ERC are already a huge improvement  over  the current state  at the example of research data.\nThe situation for research data might have improved in the last years, but the situation for code is mostly unknown and might be even worse.",
            "title": "What is the life span of an ERC?"
        },
        {
            "location": "/dev-guide/#notes-and-decisions-to-elaborate-on",
            "text": "research workflows with environmental or generated data can be  \u201cborn digital \u201d from beginning and stay that way to the end (sensors, data storage, data analysis, presentation, review, publication)  researchers do their thing and need independence/flexibility, so post-hoc creation will probably be most common and ERC must have low to no impact on workflow  data storage, citation (for giving credit) and preservation is solved (repos, DOIs, bitstream preservation in archives)  packaging methods/methodology for software is solved (R packages, Python packages, \u2026)  software preservation is  not  solved (methods are there, like migration, emulation, but complexity is too high to do this at high granularity)  reproducible paper is somewhat solved (literate programming, R package dependency handling solutions, ..)  computational RR requires sandboxing (to make sure everything is there, but also for security)  a service is needed to create ERC for researchers and executes them in a controlled environment",
            "title": "Notes and decisions to elaborate on..."
        },
        {
            "location": "/dev-guide/#why-nested-containers",
            "text": "A user shall have access to the files without starting the runtime container.\nTherefore we have at least two items, so we have a bundle and need an outer container.\nAs a bonus, the outer container can immediately be used to make an ERC conform to specific use cases, such as long term archival.\nAlso the chosen outer container solution (zip, tarball) is much older and common than the inner container standard, and thus more likely to exist longer.   \u201cWhat\u2019s oldest lasts longest.\u201d  source",
            "title": "Why nested containers?"
        },
        {
            "location": "/dev-guide/#why-your-own-configuration-file",
            "text": "Because it gives control and freedom.\nThe ERC has more than one building block, and if we want to make any of them configurable, we need a place to get users as well as tools started, an \u201centrypoint\u201d.  Why not use container labels?  The alternative of putting everything into the container itself (e.g. using image labels for metadata and configuration) can be evaluated in the future.\nThe idea is interesting as labels can be named/grouped with \u201cnamespaces\u201d and could contain more complex information than currently prevalent.  See also  #19 .",
            "title": "Why your own configuration file?"
        },
        {
            "location": "/dev-guide/#why-bagit",
            "text": "BagIt is something that preservation experts understand and covers what they care about (bitstream preservation), so it seemed a good fit in the first project vision.  BagIt originally was the required packaging for uploading of data, but that has changed. Users upload their data and analysis, and then execute the analysis to ensure the output matches what they created themselves. This is more important than correct bits, which become relevant again after creation of an ERC when it is stored and a bag is created.",
            "title": "Why BagIt?"
        },
        {
            "location": "/dev-guide/#what-about-the-limitations-of-containers",
            "text": "We are aware of the limitations that containers have.\nMost importantly the operating system and the kernel are not included.\nThis results in smaller container size and better performance (e.g. quicker start because no \u201cboot\u201d) and also has security advantages.\nHowever, it also means that the encapsulated runtime environment in ERCs is  not  \u201call the way down\u201d.  It must be noted that of course changes in the operating system and it\u2019s kernel may break a workflow encapsulated in a container.  Let\u2019s consider the  Linux Kernel .\nThose breaking changes are  very rare .  Let\u2019s consider  Docker .\nDocker containers have by now been  standardised by the OCI  and ERCs  should rely on the open standard in the future  (contributions welcome).\nThe  maintenance lifecycle  and  compatibility matrix  of Docker do not imply they are suitable for the targeted time frame for ERCs.  However, all these projects are Open Source software or documentation, and a long term provider for ERC (i.e. not a small research project) can handle these limitations in different ways, for example  organisationally  with long term maintenance contracts or  technically  as outlined in the o2r architecture  in the production architecture sketch .\nThese include specialised hardware and operating system specifics.",
            "title": "What about the limitations of containers?"
        },
        {
            "location": "/dev-guide/#why-docker",
            "text": "(Docker) containers provide an encapsulation mechanism to package all dependencies of an analysis  Docker now basically is OCI, so switching to other tools should be possible.  during container execution, and substitution, the build in  copy-on-write  storage only creates copy of files that are changed within the container, thus saving storage capacity  volume mounts allow easy substitution of input data and configurations of analysis",
            "title": "Why Docker?"
        },
        {
            "location": "/dev-guide/#why-not-singularity",
            "text": "Singularity  is an open source containerization solution.\nIt might very well be a better choice for reproducible research in the future as it stems from the scientific community (HPC), cf. also  C4RR workshop 2017 .\nAt the point of starting the specification, Docker was more widespread and implementations more readily available.\nFurthermore the origin of Singularity, high performance computing, is out of scope of ERC.  We do not see an issue in not using Singulary.\nMost importantly, the concepts  runtime manifest  and  runtime image  are abstract, i.e. independent of Docker and the concrete container tool choice could be made flexible in future versions of the specification.\nSingularity can import Docker images and as such make a transition possible, or even let an implementation use Singularity without touch the specification.",
            "title": "Why not Singularity?"
        },
        {
            "location": "/dev-guide/#why-not-just-use-plain-r",
            "text": "It would be possible to rely solely on R for replication.\nFor example, the runtime manifest could be a  codemeta  document, and the runtime environment is created based on it outside of the ERC when needed, for example by installing R in the required version.\nAdditionally a package for preserving a state of dependencies could be used, e.g.  packrat .\nThis solution is potentially less storage intensive, because containers replicate an R installation each time.\nSmaller storages might also ease collaboration.  However, none of these solutions touches the underlying system libraries.\nThe complexity of preserving the runtime environment is transferred from the packaging stage to the unpackaging stage, which is unfavourable because that packaging state \u201ceverything works\u201d, so better control is ensured at that time.\nThe burden in a plain R solution shifts from authoring to preservation.  Even though shipping system binaries within packages is possible (if not common), some packages do use system libraries which are not preserved in a plain R approach.\nAdjusting such packages is not an option.  Furthermore, none of the solutions for reproducibility are part of \u201ccore R\u201d, even if they are trustworthy (e.g. MRAN).\nCRAN does not support installing specific package versions.  That is why using an abstraction layer outside of R is preferable.",
            "title": "Why not just use plain R?"
        },
        {
            "location": "/dev-guide/#what-if-licensing-information-is-not-detailed-enough",
            "text": "Without proper license credits, the contents of an ERC would be useless based on today\u2019s copyright laws.\nTherefore we rather have the extra work for authors to define a couple of licenses than to create something that is unusable by others.  One of the biggest issues is the  scope of licenses , namely what to do about having multiple pieces of code, text, or data with different licenses.  Ideas/Notes  The  erc.yml  could also hold more complex license metadata, for specific directories or files.\nProbably this is better solved in specialised formats, though.   Example using specific licenses  ---\nid: b9b0099e-9f8d-4a33-8acf-cb0c062efaec\nspec_version: 1\nlicenses:\n  code:\n    others_lib.bin: MIT\n    my_code.c: GPL-3.0\n  data: \n    facts.csv: ODbL-1.0\n  text:\n    README.md: CC0-1.0\n        paper.Rmd: CC-BY-4.0\n      ui_bindings: CC0-1.0\n      metadata: CC0-1.0   It could even be possible to assign one license to a directory and override that assignment for a single file within that directory, or use globs or regular expressions.",
            "title": "What if licensing information is not detailed enough?"
        },
        {
            "location": "/dev-guide/#why-not-put-x-into-the-erc-configuration-file",
            "text": "identifier  makes it easier to track across platforms  is harder for manual creation    kernel  would have to use our own label within image metadata    os and architecture  are already clearly defined im image spec  can be extracted from a plain text file in the image tarball, so implementations can get them (quickly) before loading an image (a potentially costly operation)    Docker version  is already clearly defined in image spec",
            "title": "Why (not) put \"X\" into the ERC configuration file?"
        },
        {
            "location": "/dev-guide/#why-is-validation-happening-outside-the-container-and-not-in-the-container",
            "text": "better user experience (otherwise all info must be transported via stdout)  to be sure nothing is manipulated within the validation script",
            "title": "Why is validation happening outside the container and not in the container?"
        },
        {
            "location": "/dev-guide/#why-is-the-data-not-in-the-image-inner-container-but-in-the-outer-container",
            "text": "better accessible in the long term  no data duplication",
            "title": "Why is the data not in the image (inner container) but in the outer container?"
        },
        {
            "location": "/dev-guide/#erc-completeness-score",
            "text": "While the ERC is intended to be simple enough to be created manually, the clear requirements on it\u2019s contents also serve a semi-automatic creation.\nFor example, a user can upload a workspace with data files, and R Markdown document, and an HTML rendering of the document to an online platform, where the runtime manifest and image are automatically created. In such a case, metadata would still be added manually.  To encourage users, especially during the manual steps of the creation process, to provide valuable input a  completeness score  can be useful.\nComparable to profile editors on social network sites, a percentage based score can be used to highlight content or aspects going beyond the mandatory requirements.  Implementing platforms may create their own rules, for example which of the optional metadata elements contribute towards reaching a full score.\nThinking beyond merely the metadata, the score could also cover the runtime manifest (e.g. does it follow common practices, include relevant independent metadata, uses explicit versioning for dependency installation), contained code (e.g. automatic checks against code formatting guidelines, syntactical errors), and contained data (e.g. are open file formats used, maybe rewarding CSV over Shapefiles).  A completeness score can be seen as a  downstream product  based on the ERC.\nIt is unlikely this ever makes it into an ERC specification, but it can be a crucial means towards acceptance, adoption, and success of ERCs.",
            "title": "ERC completeness score"
        },
        {
            "location": "/glossary/",
            "text": "Glossary\n\u00b6\n\n\n(Computational) Analysis\n\u00b6\n\n\nA scientific workflow that is to be preserved in an ERC.\nIt conducts a number of operations on data and generates an output (text, numbers, plots).\n\n\nBag\n\u00b6\n\n\nSee \nBagIt specification\n.\n\n\n\n\nA set of opaque data contained within the structure defined by this specification.\n\n\n\n\nCompendium contents\n\u00b6\n\n\nSee \nERC contents\n\n\nContainer\n\u00b6\n\n\nA receptacle holding a collection of things (\u201cpayload\u201d or \u201ccontents\u201d).\nIn the context of this specification, two containers are distinguished: \nruntime container\n and \nouter container\n.\n\n\nCheck\n\u00b6\n\n\nA subconstituent of \nExamine\n.\nChecking an ERC is a syntactical validation, which may be largely automated by a software tool reporting the check result and potential errors.\nA check comprises (a) the validation of a concrete ERC against the ERC specification, e.g. are required files and metadata fields present, and (b) an execution of the contained analysis.\nThe execution includes a comparison of the result files in the just executed inner container with the result stored in the outer container.\n\n\nCreate\n\u00b6\n\n\nOne of the major constituents of ERC interaction.\nThe user can create an ERC by following the technical instructions included in the Specification (ERC Spec) or use the o2r reproducibility service.\nFor more information, see \nerc-spec/user-guide/creation/\n.\n\n\nDiscover\n\u00b6\n\n\nOne of the major constituents of ERC interaction.\nDiscovery comprises the \nfindability\n of the ERC as well as the exploration of its features, e.g. time and space driven search operations.\n\n\nERC\n\u00b6\n\n\nExecutable Research Compendium, see \narticle\n.\n\n\nERC contents\n\u00b6\n\n\nSee \nworkspace\n.\n\n\nERC metadata\n\u00b6\n\n\nSchema compliant information about the ERC, its contents and creators.\n\n\nExamine\n\u00b6\n\n\nOne of the major constituents of ERC interaction.\nIt comprises \nCheck\n, \nInspect\n, \nManipulate\n and \nSubstitute\n.\nTo examine an ERC means to explore its contents in depth, i.e. check the reproduced version, inspect text, code and data, manipulate interactive elements, as well as exchange input data.\n\n\nInner container\n\u00b6\n\n\nSee \nruntime container\n\n\nInspect\n\u00b6\n\n\nA subconstituent of \nExamine\n.\nInspection includes looking at all the contents of an ERC, such as code or data files, and metadata documents.\nA user conducting inspection evaluates the meaning of the ERC\u2019s artifacts.\n\n\nDependency\n\u00b6\n\n\nIf software/\nlibrary\n \nX\n is required by software/tool \nY\n to function properly, then \nY\n has the dependency \nX\n or \nX\n is a dependency of \nY\n.\nCollecting all the right dependencies, which work with each other, can be a hard problem, see \nDependency hell\n.\nDependencies can be packages of the same language (like R extension package requiring another R extension package) or system dependencies (like a Python library from PyPI requiring a specific library available via the operating system \npackage manager\n).\n\n\nDisplay file\n\u00b6\n\n\nThe file in the container that a reader software uses as the first display to a user to read text and explore graphics.\nThe entry point for \nexamination\n. \n\n\nManipulate\n\u00b6\n\n\nA subconstituent of \nExamine\n.\nA manipulation comprises interactive changing of selected, pre-defined parameters that influence the computation packaged in an ERC.\nFor example, the number of layers in a neural network, the size/selection method of the training dataset in supervised machine learning, or the variogram model of geostatistical kriging.\nThese parameters are defined via \nUI bindings\n.\n\n\nOAIS\n\u00b6\n\n\nThe \nOpen Archival Information System\n and its \nreference model\n.\n\n\nOuter container\n\u00b6\n\n\nTerm used to distinguish the \u201couter\u201d \nBag\n from the embedded \nruntime container\n.\n\n\nReproducible, Reproducibility, Replication\n\u00b6\n\n\nSee \nsection 2.1 \u201cDefinition of Reproducibility\u201d\n.\n\n\nRuntime container\n\u00b6\n\n\nA \nLinux container\n, more specifically a \nDocker container\n, which is a special format to package an application and its \ndependencies\n.\nFor usage in this specification, the runtime container can be used to provide the \ncomputational environment\n needed for execution of an ERC\u2019s workflow.\nIt is a transferable snapshot of the authors computer, but also documents the software used by an ERC.\n\n\nRuntime manifest\n\u00b6\n\n\nA formal description or recipe for a \nruntime container\n, more specifically a \nDockerfile\n.\n\n\n\n\nDocker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image.\n \nsource\n\n\n\n\nSubstitute\n\u00b6\n\n\nA subconstituent of \nExamine\n.\nDuring a substitution, compatible parts of an ERC are exchanged, e.g. similar data sets for a given analysis, or exchanging an analysis script.\nA substitution process usually creates a new ERC based on two input ERCs: the \nbase ERC\n and the \noverlay ERC\n.\nOne or several data or code files from the \noverlay ERC\n replace corresponding files in the \nbase ERC\n, to create a new ERC.\n\n\nUI bindings\n\u00b6\n\n\nFormal descriptions of parameters and interactions used during \nExamine\n.\nThe UI bindings are included in the configuration file and may be created manually or with help of a user-friendly wizard.\n\n\nWorkspace\n\u00b6\n\n\nThe files created by the author of the original analysis.\nThe workspace is packaged together with ERC metadata, \nruntime container\n and \nruntime manifest\n in the payload directory of the \nouter container\n.",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#computational-analysis",
            "text": "A scientific workflow that is to be preserved in an ERC.\nIt conducts a number of operations on data and generates an output (text, numbers, plots).",
            "title": "(Computational) Analysis"
        },
        {
            "location": "/glossary/#bag",
            "text": "See  BagIt specification .   A set of opaque data contained within the structure defined by this specification.",
            "title": "Bag"
        },
        {
            "location": "/glossary/#compendium-contents",
            "text": "See  ERC contents",
            "title": "Compendium contents"
        },
        {
            "location": "/glossary/#container",
            "text": "A receptacle holding a collection of things (\u201cpayload\u201d or \u201ccontents\u201d).\nIn the context of this specification, two containers are distinguished:  runtime container  and  outer container .",
            "title": "Container"
        },
        {
            "location": "/glossary/#check",
            "text": "A subconstituent of  Examine .\nChecking an ERC is a syntactical validation, which may be largely automated by a software tool reporting the check result and potential errors.\nA check comprises (a) the validation of a concrete ERC against the ERC specification, e.g. are required files and metadata fields present, and (b) an execution of the contained analysis.\nThe execution includes a comparison of the result files in the just executed inner container with the result stored in the outer container.",
            "title": "Check"
        },
        {
            "location": "/glossary/#create",
            "text": "One of the major constituents of ERC interaction.\nThe user can create an ERC by following the technical instructions included in the Specification (ERC Spec) or use the o2r reproducibility service.\nFor more information, see  erc-spec/user-guide/creation/ .",
            "title": "Create"
        },
        {
            "location": "/glossary/#discover",
            "text": "One of the major constituents of ERC interaction.\nDiscovery comprises the  findability  of the ERC as well as the exploration of its features, e.g. time and space driven search operations.",
            "title": "Discover"
        },
        {
            "location": "/glossary/#erc",
            "text": "Executable Research Compendium, see  article .",
            "title": "ERC"
        },
        {
            "location": "/glossary/#erc-contents",
            "text": "See  workspace .",
            "title": "ERC contents"
        },
        {
            "location": "/glossary/#erc-metadata",
            "text": "Schema compliant information about the ERC, its contents and creators.",
            "title": "ERC metadata"
        },
        {
            "location": "/glossary/#examine",
            "text": "One of the major constituents of ERC interaction.\nIt comprises  Check ,  Inspect ,  Manipulate  and  Substitute .\nTo examine an ERC means to explore its contents in depth, i.e. check the reproduced version, inspect text, code and data, manipulate interactive elements, as well as exchange input data.",
            "title": "Examine"
        },
        {
            "location": "/glossary/#inner-container",
            "text": "See  runtime container",
            "title": "Inner container"
        },
        {
            "location": "/glossary/#inspect",
            "text": "A subconstituent of  Examine .\nInspection includes looking at all the contents of an ERC, such as code or data files, and metadata documents.\nA user conducting inspection evaluates the meaning of the ERC\u2019s artifacts.",
            "title": "Inspect"
        },
        {
            "location": "/glossary/#dependency",
            "text": "If software/ library   X  is required by software/tool  Y  to function properly, then  Y  has the dependency  X  or  X  is a dependency of  Y .\nCollecting all the right dependencies, which work with each other, can be a hard problem, see  Dependency hell .\nDependencies can be packages of the same language (like R extension package requiring another R extension package) or system dependencies (like a Python library from PyPI requiring a specific library available via the operating system  package manager ).",
            "title": "Dependency"
        },
        {
            "location": "/glossary/#display-file",
            "text": "The file in the container that a reader software uses as the first display to a user to read text and explore graphics.\nThe entry point for  examination .",
            "title": "Display file"
        },
        {
            "location": "/glossary/#manipulate",
            "text": "A subconstituent of  Examine .\nA manipulation comprises interactive changing of selected, pre-defined parameters that influence the computation packaged in an ERC.\nFor example, the number of layers in a neural network, the size/selection method of the training dataset in supervised machine learning, or the variogram model of geostatistical kriging.\nThese parameters are defined via  UI bindings .",
            "title": "Manipulate"
        },
        {
            "location": "/glossary/#oais",
            "text": "The  Open Archival Information System  and its  reference model .",
            "title": "OAIS"
        },
        {
            "location": "/glossary/#outer-container",
            "text": "Term used to distinguish the \u201couter\u201d  Bag  from the embedded  runtime container .",
            "title": "Outer container"
        },
        {
            "location": "/glossary/#reproducible-reproducibility-replication",
            "text": "See  section 2.1 \u201cDefinition of Reproducibility\u201d .",
            "title": "Reproducible, Reproducibility, Replication"
        },
        {
            "location": "/glossary/#runtime-container",
            "text": "A  Linux container , more specifically a  Docker container , which is a special format to package an application and its  dependencies .\nFor usage in this specification, the runtime container can be used to provide the  computational environment  needed for execution of an ERC\u2019s workflow.\nIt is a transferable snapshot of the authors computer, but also documents the software used by an ERC.",
            "title": "Runtime container"
        },
        {
            "location": "/glossary/#runtime-manifest",
            "text": "A formal description or recipe for a  runtime container , more specifically a  Dockerfile .   Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image.   source",
            "title": "Runtime manifest"
        },
        {
            "location": "/glossary/#substitute",
            "text": "A subconstituent of  Examine .\nDuring a substitution, compatible parts of an ERC are exchanged, e.g. similar data sets for a given analysis, or exchanging an analysis script.\nA substitution process usually creates a new ERC based on two input ERCs: the  base ERC  and the  overlay ERC .\nOne or several data or code files from the  overlay ERC  replace corresponding files in the  base ERC , to create a new ERC.",
            "title": "Substitute"
        },
        {
            "location": "/glossary/#ui-bindings",
            "text": "Formal descriptions of parameters and interactions used during  Examine .\nThe UI bindings are included in the configuration file and may be created manually or with help of a user-friendly wizard.",
            "title": "UI bindings"
        },
        {
            "location": "/glossary/#workspace",
            "text": "The files created by the author of the original analysis.\nThe workspace is packaged together with ERC metadata,  runtime container  and  runtime manifest  in the payload directory of the  outer container .",
            "title": "Workspace"
        },
        {
            "location": "/support/",
            "text": "Support\n\u00b6\n\n\nIf you have questions about the ERC specification and its usage which are not answered by the \nuser and developer guides\n, feel free to contact us using the options below.\n\n\nEmail\n\u00b6\n\n\ndaniel.nuest@uni-muenster.de\n\n\nDiscussion forum\n\u00b6\n\n\n\n\n\n\n    var disqus_config = function () {\n        this.page.url = \"http://o2r.info/erc-spec/support\";\n        this.page.identifier = \"erc-spec-support\";\n    };\n    (function() {\n        var d = document, s = d.createElement('script');\n        s.src = '//o2r-blog.disqus.com/embed.js';\n        s.setAttribute('data-timestamp', +new Date());\n        (d.head || d.body).appendChild(s);\n    })();\n\n\n\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.",
            "title": "Support"
        },
        {
            "location": "/support/#support",
            "text": "If you have questions about the ERC specification and its usage which are not answered by the  user and developer guides , feel free to contact us using the options below.",
            "title": "Support"
        },
        {
            "location": "/support/#email",
            "text": "daniel.nuest@uni-muenster.de",
            "title": "Email"
        },
        {
            "location": "/support/#discussion-forum",
            "text": "var disqus_config = function () {\n        this.page.url = \"http://o2r.info/erc-spec/support\";\n        this.page.identifier = \"erc-spec-support\";\n    };\n    (function() {\n        var d = document, s = d.createElement('script');\n        s.src = '//o2r-blog.disqus.com/embed.js';\n        s.setAttribute('data-timestamp', +new Date());\n        (d.head || d.body).appendChild(s);\n    })();   Please enable JavaScript to view the  comments powered by Disqus.",
            "title": "Discussion forum"
        }
    ]
}